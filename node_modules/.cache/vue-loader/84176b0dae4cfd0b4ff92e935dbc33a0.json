{"remainingRequest":"/Users/brianphan/jets/kf-grower-portal/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/brianphan/jets/kf-grower-portal/src/components/charts/InsectBarChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/brianphan/jets/kf-grower-portal/src/components/charts/InsectBarChart.vue","mtime":1617306999853},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KCi8qIGVzbGludC1kaXNhYmxlKi8KaW1wb3J0IGZvcm1hdE51bWJlciBmcm9tICdAL2xpYi91dGlscy9mb3JtYXROdW1iZXInOwppbXBvcnQgY29sb3JzIGZyb20gJ0AvYXNzZXRzL2pzL2NvbG9ycyc7CmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJzsKaW1wb3J0IEJhc2VDaGFydCBmcm9tICcuL0Jhc2VDaGFydCc7CmltcG9ydCBDaGFydExlZ2VuZCBmcm9tICcuLi9DaGFydExlZ2VuZCc7CgpleHBvcnQgZGVmYXVsdCB7CgluYW1lICAgIDogJ3F1YWxpdHktYmFyLWNoYXJ0JywKCWV4dGVuZHMgOiBCYXNlQ2hhcnQsCglwcm9wcyAgIDogewoJCWNoYXJ0IDogewoJCQl0eXBlICAgIDogT2JqZWN0LAoJCQlkZWZhdWx0IDogKCkgPT4gKCB7CgkJCQlsYWJlbCAgICAgOiAnUG91bmRzIFByb2R1Y2VkIGluIEZha2UgRGF0YScsCgkJCQl1cGRhdGVkQXQgOiBuZXcgRGF0ZSgpLAoJCQkJZGF0YSAgICAgIDogW3sKCQkJCQl2YWx1ZSA6IDIyMCwKCQkJCQlsYWJlbCA6ICdBbGwgRmllbGRzJywKCQkJCQljb2xvciA6ICcjRTVCRjExJywKCQkJCX1dLAoJCQl9ICksCgkJfSwKCQlvcHRpb25zIDogewoJCQl0eXBlICAgIDogT2JqZWN0LAoJCQlkZWZhdWx0IDogKCkgPT4gKCB7CgkJCQloYXNCYXJMYWJlbHMgOiB0cnVlCgkJCX0gKQoJCX0KCX0sCglkYXRhIDogKCkgPT4gKCB7CgkJYmFyTGFiZWxIZWlnaHQgIDogMzAsCgkJYmFyTGFiZWxTcGFjaW5nIDogNQoJfSApLAoJY29tcG9uZW50cyA6IHsKCQlDaGFydExlZ2VuZAoJfSwKCgljb21wdXRlZCA6IHsKCQliYXJXaWR0aCgpIHsKCQkJY29uc3QgeyBhdyB9ID0gdGhpczsKCQkJcmV0dXJuIDUwOwoJCQkvLyByZXR1cm4gTWF0aC5taW4oIGF3IC8gdGhpcy5jaGFydC5kYXRhLmxlbmd0aCwgMzAgKTsKCQl9LAoJCWJhclNwYWNpbmcoKSB7CgkJCWNvbnN0IHsgYmFyV2lkdGgsIGRhdGEsIGF3IH0gPSB0aGlzOwoJCQkvLyBjb25zb2xlLmxvZyggYmFyV2lkdGggKTsKCQkJcmV0dXJuICggYXcgLSAoIGJhcldpZHRoICogdGhpcy5jaGFydC5kYXRhLmxlbmd0aCApICkgLyB0aGlzLmNoYXJ0LmRhdGEubGVuZ3RoOwoJCX0sCgkJbGFiZWxUZXh0U2l6ZSgpIHsKCQkJcmV0dXJuIHRoaXMuYmFyV2lkdGggKiAwLjc1OwoJCX0KCX0sCgltb3VudGVkKCkgewoJCS8vIGNvbnNvbGUubG9nKCdtb3VudGVkIEJhckNoYXJ0Jyk7CgkJdGhpcy5pbml0KCB0aGlzLiRyZWZzLnN2ZyApOwoJfSwKCW1ldGhvZHMgOiB7CgkJZHJhdygpIHsKCQkJdGhpcy51cGRhdGVEaW1zKCB7CgkJCQlsIDogNSwKCQkJCXIgOiA1LAoJCQkJdCA6IDMwCgkJCX0gKTsKCQkJY29uc3QgeyB2YWx1ZXMgfSA9IHRoaXMuY2hhcnQuZGF0YS5tYXAoIGVudHJ5ID0+IGVudHJ5LmxhYmVsICk7CgkJCWNvbnN0IHlWYWx1ZXMgPSB0aGlzLmNoYXJ0LmRhdGEubWFwKCBlbnRyeSA9PiBlbnRyeS52YWx1ZSApOwoJCQkvLyBjb25zdCBzdW0gPSBPYmplY3Qua2V5cyggdmFsdWVzICkucmVkdWNlKCAoIHRvdGFsLCBrZXkgKSA9PiB0b3RhbCArIHZhbHVlc1trZXldLCAwICk7CgkJCWNvbnN0IHN1bSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCB5VmFsdWVzLCBmYWxzZSApLmVuZDsKCQkJLy8gY29uc3QgeVZhbHVlcyA9IHRoaXMuY2hhcnQuZGF0YVswXS5tYXAoIGRhdHVtID0+IGRhdHVtLnZhbHVlICk7CgkJCWNvbnN0IHJhbmdlICAgPSB7IHN0YXJ0IDogMCwgZW5kIDogc3VtIH07CgoJCQlpZiAoIHRoaXMuaGFzQmFyTGFiZWxzICkgewoJCQkJdGhpcy51cGRhdGVEaW1zKCB7CgkJCQkJdCA6IHRoaXMudCArIHRoaXMuYmFyTGFiZWxIZWlnaHQgKyB0aGlzLmJhckxhYmVsU3BhY2luZwoJCQkJfSApOwoJCQl9CgkJCS8vIGRyYXcgeS1heGlzIGxhYmVscwoKCQkJY29uc3QgeUF4aXNEYXRhID0gdGhpcy5kcmF3QXhpc0luZGljYXRvcnMoIHsKCQkJCWF4aXMgICAgICAgICAgIDogJ3ktcmlnaHQnLAoJCQkJdHJhbnNmb3JtTGFiZWwgOiB0ZXh0ID0+IGZvcm1hdE51bWJlciggdGV4dCApLAoJCQkJbGluZXMgICAgICAgICAgOiB7CgkJCQkJbnVtYmVyT2ZJbmRpY2F0b3JzICAgICAgICAgOiA2LAoJCQkJCXNwYWNlQmV0d2VlbkxhYmVsc0FuZExpbmVzIDogMTAsCgkJCQl9LAoJCQkJY29sb3IgOiBjb2xvcnMuY29sb3JQcmltYXJ5LAoJCQkJZGlmZmVyZW50Rmlyc3RBbmRMYXN0TGFiZWxzOiBmYWxzZSwKCQkJCXJhbmdlLAoJCQl9ICk7CgoJCQkvLyBjb25zb2xlLmxvZyggeUF4aXNEYXRhICk7CgkJCS8vIGRyYXcgeC1heGlzIGxhYmVscwoJCQljb25zdCB4QXhpc0RhdGEgPSB0aGlzLmRyYXdBeGlzSW5kaWNhdG9ycyggewoJCQkJYXhpcyAgICAgICAgICAgICAgICAgICAgICAgOiAneC1ib3R0b20nLAoJCQkJdmFsdWVzICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmNoYXJ0LmRhdGEsCgkJCQlzcGFjZUJldHdlZW5MYWJlbHNBbmRDaGFydCA6IDEwLAoJCQkJbGFiZWxTdHlsZSAgICAgICAgICAgICAgICAgOiBbCgkJCQkJWydmb250LXNpemUnLCAnMTRweCddLAoJCQkJCVsnZm9udC13ZWlnaHQnLCAnNzAwJ10sCgkJCQkJWydmb250LWZhbWlseScsICciTWFuamFyaSIsIHNhbnMtc2VyaWYnXSwKCQkJCV0sCgkJCX0gKTsKCQkJLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIGJhcnMKCQkJY29uc3QgYmFyRGF0YSAgID0gdGhpcy5uZXdDb21wdXRlQmFyRGF0YSggKTsKCQkJY29uc3QgYmFyR3JvdXBzID0gdGhpcy5uZXdEcmF3QmFycyggYmFyRGF0YSApOwoKCQkJdGhpcy5kcmF3QmFyTGFiZWxzKCBiYXJHcm91cHMgKTsKCgoJCX0sCgoJCW5ld0NvbXB1dGVCYXJEYXRhKCApIHsKCQkJY29uc3QgdmFsdWVzID0gdGhpcy5jaGFydC5kYXRhLm1hcCggZW50cnkgPT4gZW50cnkudmFsdWUgKTsKCQkJY29uc3QgeyBlbmQgfSA9IHRoaXMuZ2V0RGF0YVJhbmdlKCB2YWx1ZXMsIGZhbHNlICk7CgkJCWNvbnN0IHN1bSA9IHRoaXMuY2hhcnQuZGF0YS5yZWR1Y2UoICggdG90YWwsIGVudHJ5ICkgPT4gdG90YWwgKyBlbnRyeS52YWx1ZSwgMCApOwoJCQlyZXR1cm4gdGhpcy5jaGFydC5kYXRhLm1hcCggKCBlbnRyeSwgaSApID0+IHsKCQkJCWNvbnN0IHsgdmFsdWUgfSA9IGVudHJ5OwoJCQkJY29uc3QgaGVpZ2h0ID0gKCB2YWx1ZSAvIGVuZCApICogdGhpcy5haDsKCQkJCWNvbnN0IHkgPSB0aGlzLnQgKyAoIHRoaXMuYWggLSBoZWlnaHQgKTsKCQkJCXJldHVybiB7CgkJCQkJd2lkdGggOiB0aGlzLmJhcldpZHRoLAoJCQkJCWNvbG9yIDogZW50cnkuY29sb3IsCgkJCQkJeCAgICAgOiB0aGlzLmdldFgoIGkgKSwKCQkJCQkvLyB4ICAgICA6IHRoaXMubCArIHhEaW1zW2ldLngsCgkJCQkJbGFiZWwgOiBlbnRyeS5sYWJlbCwKCQkJCQl2YWx1ZSA6IGVudHJ5LnZhbHVlLAoJCQkJCXksCgkJCQkJaGVpZ2h0CgkJCQl9OwoJCQl9ICk7CgkJfSwKCQluZXdEcmF3WGF4aXMoIGJhckdyb3VwcyApIHsKCQkJY29uc3QgeEF4aXNMYWJlbHMgPSBiYXJHcm91cHMKCQkJCS5hcHBlbmQoICd0ZXh0JyApCgkJCQkuYXR0ciggJ2NsYXNzJywgJ3gtYXhpcy1sYWJlbHMnICkKCQkJCS5hdHRyKCAneCcsICggZCwgaSApID0+IHRoaXMuZ2V0VGV4dFgoIGkgKSApCgkJCQkuYXR0ciggJ3knLCB0aGlzLnQgKyB0aGlzLmFoICkKCQkJCS5hdHRyKCAndGV4dC1hbmNob3InLCAnbWlkZGxlJyApCgkJCQkuYXR0ciggJ2RvbWluYW50LWJhc2VsaW5lJywgJ3N0YXJ0JyApCgkJCQkuc3R5bGUoICdmb250LXNpemUnLCAnMTJweCcgKQoJCQkJLnRleHQoIGQgPT4gZC5sYWJlbCApOwoJCQl0aGlzLmNoYW5nZVdpdGhNb2RlKCB7CgkJCQlub2RlcyAgIDogeEF4aXNMYWJlbHMsCgkJCQlvcHRpb25zIDogewoJCQkJCWRheSA6IHsKCQkJCQkJc3R5bGUgOiBbCgkJCQkJCQlbJ2ZpbGwnLCBjb2xvcnMuZ3JleV0sCgkJCQkJCV0sCgkJCQkJfSwKCQkJCQluaWdodCA6IHsKCQkJCQkJc3R5bGUgOiBbCgkJCQkJCQlbJ2ZpbGwnLCBjb2xvcnMud2hpdGVdLAoJCQkJCQldLAoJCQkJCX0sCgkJCQl9LAoJCQl9ICk7CgkJCWNvbnN0IGJhckxhYmVsTm9kZXMgPSBiYXJHcm91cHMuc2VsZWN0QWxsKCAnLngtYXhpcy1sYWJlbHMnICk7CgkJCWNvbnN0IGJhckxhYmVsV2lkdGhzID0gQXJyYXkuZnJvbSggYmFyTGFiZWxOb2Rlcy5fZ3JvdXBzWzBdICkubWFwKCBhID0+IGEuZ2V0QkJveCgpLmhlaWdodCApOwoJCQljb25zdCBiaWdnZXN0QmFyTGFiZWwgPSBNYXRoLm1heCggLi4uYmFyTGFiZWxXaWR0aHMgKTsKCQkJY29uc3Qgc3BhY2VCZXR3ZWVuQmFyQW5kWEF4aXMgPSAyOwoJCQl0aGlzLnVwZGF0ZURpbXMoIHsKCQkJCWIgOiBiaWdnZXN0QmFyTGFiZWwgKyBzcGFjZUJldHdlZW5CYXJBbmRYQXhpcwoJCQl9ICk7CgkJCXJldHVybiB4QXhpc0xhYmVsczsKCQl9LAoJCW5ld0RyYXdCYXJzKCBiYXJEYXRhICkgewoJCQljb25zdCBiYXJHcm91cHMgPSB0aGlzLmNhbnZhcy5zZWxlY3RBbGwoIGBiYXJzLSR7dGhpcy5pZH1gICkKCQkJCS5kYXRhKCBiYXJEYXRhICkKCQkJCS5lbnRlcigpCgkJCQkuYXBwZW5kKCAnZycgKTsKCgkJCWJhckdyb3VwcwoJCQkJLmFwcGVuZCggJ3JlY3QnICkKCQkJCS5hdHRyKCAneCcsIGQgPT4gZC54ICkKCQkJCS5hdHRyKCAneScsIGQgPT4gZC55ICkKCQkJCS8vIC5hdHRyKCAnZmlsbCcsIGQgPT4gZC5jb2xvciApCgkJCQkuYXR0ciggJ2ZpbGwnLCBkID0+IGQuY29sb3IgKQoJCQkJLmF0dHIoICdoZWlnaHQnLCBkID0+IGQuaGVpZ2h0ICkKCQkJCS5hdHRyKCAnd2lkdGgnLCBkID0+IGQud2lkdGggKQoJCQkJLmF0dHIoICdzdHJva2UnLCBkID0+IGQuY29sb3IgKQoJCQkJLmF0dHIoICdvcGFjaXR5JywgMC44ICkKCQkJCS5hdHRyKCAnc3Ryb2tlLXdpZHRoJywgZCA9PiAnMicgKQoJCQkJLmF0dHIoJ3J4JywgJzAnKQoJCQkJLmF0dHIoICdjbGFzcycsIGBiYXItJHt0aGlzLmlkfSB0cmFuc2xhdGUtJHt0aGlzLmlkfWAgKTsKCgkJCWNvbnN0IHJvdW5kVG9OZWFyZXN0TXVsdGlwbGVPZkVpZ2h0ID0gbnVtID0+IE1hdGguY2VpbCggTWF0aC5jZWlsKCBudW0gKSAvIDggKSAqIDg7CgkJCXJldHVybiBiYXJHcm91cHM7CgkJfSwKCgoJCWRyYXdCYXJMYWJlbHMoIGJhckdyb3VwcyApIHsKCQkJY29uc3QgYmFyTGFiZWxHcm91cHMgPSBiYXJHcm91cHMKCQkJCS5hcHBlbmQoICdnJyApOwoJCQljb25zdCB0ZXh0TGFiZWxzID0gYmFyTGFiZWxHcm91cHMuYXBwZW5kKCAndGV4dCcgKQoJCQkJLmF0dHIoICd4JywgKCBkLCBpICkgPT4gdGhpcy5nZXRUZXh0WCggaSApLTkwICkKCQkJCS5hdHRyKCAneScsICggZCApID0+IHsKCQkJCQljb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCggZC52YWx1ZSApOwoJCQkJCWNvbnN0IHkgPSB0aGlzLmdldFkoIGhlaWdodCApOwoJCQkJCXJldHVybiB5IC0gKCAoIHRoaXMuYmFyTGFiZWxIZWlnaHQgLyAyICkgKyB0aGlzLmJhckxhYmVsU3BhY2luZyApOwoJCQkJfSApCgkJCQkuYXR0ciggJ2NsYXNzJywgJ2Jhci12YWx1ZScgKQoJCQkJLmF0dHIoICd0ZXh0LWFuY2hvcicsICdtaWRkbGUnICkKCQkJCS5hdHRyKCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnbWlkZGxlJyApCgkJCQkuc3R5bGUoICdmaWxsJywgZCA9PiBkLmNvbG9yICkKCQkJCS5zdHlsZSggJ2ZvbnQtd2VpZ2h0JywgJ2JvbGQnICkKCQkJCS5zdHlsZSggJ2ZvbnQtZmFtaWx5JywgJ1JvYm90byBTbGFiJyApCgkJCQkuc3R5bGUoICdmb250LXNpemUnLCBgJHt0aGlzLmxhYmVsVGV4dFNpemV9cHhgICkKCQkJCS50ZXh0KCBkID0+IGZvcm1hdE51bWJlcihkLnZhbHVlKSApOwoKCQkJYmFyTGFiZWxHcm91cHMuYXBwZW5kKCAndGV4dCcgKQoJCQkJLmF0dHIoICd4JywgKCBkLCBpICkgPT4gdGhpcy5nZXRUZXh0WCggaSApLTkwICkKCQkJCS5hdHRyKCAneScsICggZCApID0+IHsKCQkJCQljb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCggZC52YWx1ZSApOwoJCQkJCWNvbnN0IHkgPSB0aGlzLmdldFkoIGhlaWdodCApOwoJCQkJCXJldHVybiB5IC0gKCAoIHRoaXMuYmFyTGFiZWxIZWlnaHQgLyAyICkgKyB0aGlzLmJhckxhYmVsU3BhY2luZyApKzMwOwoJCQkJfSApCgkJCQkuYXR0ciggJ2NsYXNzJywgJ2Jhci12YWx1ZScgKQoJCQkJLmF0dHIoICd0ZXh0LWFuY2hvcicsICdtaWRkbGUnICkKCQkJCS5hdHRyKCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnbWlkZGxlJyApCgkJCQkuc3R5bGUoICdmaWxsJywgY29sb3JzLmNvbG9yUHJpbWFyeSApCgkJCQkuc3R5bGUoICdmb250LWZhbWlseScsICdSb2JvdG8gU2xhYicgKQoJCQkJLnN0eWxlKCAnZm9udC1zaXplJywgYDIwcHhgICkKCQkJCS50ZXh0KCBkID0+ICJQb3VuZHMiICk7CgoJCQliYXJMYWJlbEdyb3Vwcy5hcHBlbmQoICd0ZXh0JyApCgkJCQkuYXR0ciggJ3gnLCAoIGQsIGkgKSA9PiB0aGlzLmdldFRleHRYKCBpICktOTAgKQoJCQkJLmF0dHIoICd5JywgKCBkICkgPT4gewoJCQkJCWNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCBkLnZhbHVlICk7CgkJCQkJY29uc3QgeSA9IHRoaXMuZ2V0WSggaGVpZ2h0ICk7CgkJCQkJcmV0dXJuIHkgLSAoICggdGhpcy5iYXJMYWJlbEhlaWdodCAvIDIgKSArIHRoaXMuYmFyTGFiZWxTcGFjaW5nICkrNTA7CgkJCQl9ICkKCQkJCS5hdHRyKCAnY2xhc3MnLCAnYmFyLXZhbHVlJyApCgkJCQkuYXR0ciggJ3RleHQtYW5jaG9yJywgJ21pZGRsZScgKQoJCQkJLmF0dHIoICdkb21pbmFudC1iYXNlbGluZScsICdtaWRkbGUnICkKCQkJCS5zdHlsZSggJ2ZpbGwnLCBjb2xvcnMuY29sb3JQcmltYXJ5ICkKCQkJCS5zdHlsZSggJ2ZvbnQtZmFtaWx5JywgJ1JvYm90byBTbGFiJyApCgkJCQkuc3R5bGUoICdmb250LXNpemUnLCBgMjBweGAgKQoJCQkJLnRleHQoIGQgPT4gImRhbWFnZWQiICk7CgoJCQliYXJMYWJlbEdyb3Vwcy5hcHBlbmQoICd0ZXh0JyApCgkJCQkuYXR0ciggJ3gnLCAoIGQsIGkgKSA9PiB0aGlzLmdldFRleHRYKCBpICktOTAgKQoJCQkJLmF0dHIoICd5JywgKCBkICkgPT4gewoJCQkJCWNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCBkLnZhbHVlICk7CgkJCQkJY29uc3QgeSA9IHRoaXMuZ2V0WSggaGVpZ2h0ICk7CgkJCQkJcmV0dXJuIHkgLSAoICggdGhpcy5iYXJMYWJlbEhlaWdodCAvIDIgKSArIHRoaXMuYmFyTGFiZWxTcGFjaW5nICkrNzA7CgkJCQl9ICkKCQkJCS5hdHRyKCAnY2xhc3MnLCAnYmFyLXZhbHVlJyApCgkJCQkuYXR0ciggJ3RleHQtYW5jaG9yJywgJ21pZGRsZScgKQoJCQkJLmF0dHIoICdkb21pbmFudC1iYXNlbGluZScsICdtaWRkbGUnICkKCQkJCS5zdHlsZSggJ2ZpbGwnLCBjb2xvcnMuY29sb3JQcmltYXJ5ICkKCQkJCS5zdHlsZSggJ2ZvbnQtZmFtaWx5JywgJ1JvYm90byBTbGFiJyApCgkJCQkuc3R5bGUoICdmb250LXNpemUnLCBgMjBweGAgKQoJCQkJLnRleHQoICJpbiAyMDIwIiApOwoKCgoKCQkJY29uc3QgdGV4dERpbXMgPSBBcnJheS5mcm9tKAoJCQkJdGV4dExhYmVscy5fZ3JvdXBzWzBdCgkJCSkubWFwKAoJCQkJdGV4dCA9PiBkMy5zZWxlY3QoIHRleHQgKQoJCQkJCS5ub2RlKCkKCQkJCQkuZ2V0QkJveCgpCgkJCSk7CgoJCX0sCgkJZHJhd1hBeGlzSW5kaWNhdG9ycyggb3B0aW9ucyApIHsKCQkJY29uc3QgewoJCQkJYXhpcywKCQkJCXZhbHVlcywKCQkJCXNwYWNlQmV0d2VlbkxhYmVsc0FuZENoYXJ0LAoJCQkJbGFiZWxTdHlsZSwKCQkJfSA9IG9wdGlvbnM7CgoJCQljb25zdCBnZXRYID0gKCBpICkgPT4gewoJCQkJY29uc3QgeyBhdywgbCB9ID0gdGhpczsKCgkJCQlyZXR1cm4gbCArICggKCBhdyAvICggdmFsdWVzLmxlbmd0aCArIDEgKSApICogKCBpICsgMSApICk7CgkJCX07CgoJCQljb25zdCB4QXhpc0RhdGEgPSB2YWx1ZXMubWFwKCAoIGRhdHVtLCBpICkgPT4gewoKCQkJCWNvbnN0IHkgPSAoKSA9PiAoICggYXhpcyA9PT0gJ3gtdG9wJyApID8gdGhpcy50IDogdGhpcy50ICsgdGhpcy5haCApOwoJCQkJY29uc3QgeCA9ICgpID0+IGdldFgoIGkgKTsKCQkJCXJldHVybiB7CgkJCQkJLi4uZGF0dW0sCgkJCQkJeCwKCQkJCQl5LAoJCQkJCXRleHRBbmNob3IgICAgICAgOiAnbWlkZGxlJywKCQkJCQlkb21pbmFudEJhc2VsaW5lIDogKCBheGlzID09PSAneC10b3AnICkgPyAndGV4dC1iZWZvcmUtZWRnZScgOiAndGV4dC1hZnRlci1lZGdlJywKCQkJCX07CgkJCX0gKTsKCgkJCWNvbnN0IHhBeGlzTGFiZWxzID0gdGhpcy5jYW52YXMKCQkJCS5zZWxlY3RBbGwoICd4LWF4aXMtbGFiZWxzIGF4aXMtbGFiZWwnICkKCQkJCS5kYXRhKCB4QXhpc0RhdGEgKQoJCQkJLmVudGVyKCkKCQkJCS5hcHBlbmQoICd0ZXh0JyApCgkJCQkuYXR0ciggJ3RleHQtYW5jaG9yJywgZCA9PiBkLnRleHRBbmNob3IgKQoJCQkJLmF0dHIoICd4JywgKCBkLCBpICkgPT4gdGhpcy5nZXRUZXh0WCggaSApICkKCQkJCS5hdHRyKCAneScsIGQgPT4gZC55KCkgKQoJCQkJLmF0dHIoICdkb21pbmFudC1iYXNlbGluZScsIGQgPT4gZC5kb21pbmFudEJhc2VsaW5lICkKCQkJCS5zdHlsZSggJ2ZpbGwnLCBjb2xvcnMuY29sb3JQcmltYXJ5ICkKCQkJCS50ZXh0KCBkID0+IGQubGFiZWwgKTsKCgkJCWlmICggbGFiZWxTdHlsZSApIHsKCQkJCXRoaXMuYXBwbHlNZXRob2RzKCB4QXhpc0xhYmVscywgJ3N0eWxlJywgbGFiZWxTdHlsZSApOwoJCQl9CgoJCQljb25zdCB4QXhpc0xhYmVsRGltcyAgICA9IEFycmF5LmZyb20oIHhBeGlzTGFiZWxzLl9ncm91cHNbMF0gKS5tYXAoIGEgPT4gYS5nZXRCQm94KCkgKTsKCQkJY29uc3QgeEF4aXNMYWJlbEhlaWdodHMgPSB4QXhpc0xhYmVsRGltcy5tYXAoIGEgPT4gYS5oZWlnaHQgKTsKCQkJLy8gY29uc3QgeEF4aXNMYWJlbFdpZHRocyAgPSB4QXhpc0xhYmVsRGltcy5tYXAoIGEgPT4gYS53aWR0aCApOwoJCQljb25zdCBiaWdnZXN0WEF4aXNMYWJlbCA9IE1hdGgubWF4KCAuLi54QXhpc0xhYmVsSGVpZ2h0cyApOwoKCQkJY29uc3QgZGltcyA9ICggKCkgPT4gewoJCQkJaWYgKCBheGlzID09PSAneS10b3AnICkgewoJCQkJCXJldHVybiB7CgkJCQkJCXQgOiBiaWdnZXN0WEF4aXNMYWJlbCArIHNwYWNlQmV0d2VlbkxhYmVsc0FuZENoYXJ0LAoJCQkJCX07CgkJCQl9CgoJCQkJcmV0dXJuIHsKCQkJCQliIDogYmlnZ2VzdFhBeGlzTGFiZWwgKyBzcGFjZUJldHdlZW5MYWJlbHNBbmRDaGFydCwKCQkJCX07CgkJCX0gKSgpOwoKCQkJdGhpcy51cGRhdGVEaW1zKCBkaW1zICk7CgkJCXRoaXMucmVhbGlnbkF4aXNMYWJlbHMoKTsKCgkJCS8vID8gY2VudGVyIHRleHRzIGFzIG5lY2Vzc2FyeQoJCQkvLyBjb25zdCB0b3RhbFRleHRTcGFjZSA9IHhBeGlzTGFiZWxXaWR0aHMucmVkdWNlKCAoIHN1bSwgdyApID0+IHN1bSArIHcsIDAgKTsKCQkJLy8gY29uc3QgbGVmdE92ZXJTcGFjZSAgPSB0aGlzLmF3IC0gdG90YWxUZXh0U3BhY2U7CgkJCS8vIGNvbnN0IHNwYWNlQXJvdW5kICAgID0gKCBsZWZ0T3ZlclNwYWNlIC8gKCB2YWx1ZXMubGVuZ3RoICsgMSApICk7CgoJCQlyZXR1cm4geEF4aXNMYWJlbERpbXM7CgoJCX0sCgkJZ2V0WCggaSApIHsKCQkJY29uc3QgewoJCQkJbCwKCQkJCWJhcldpZHRoLAoJCQkJYmFyU3BhY2luZywKCQkJfSA9IHRoaXM7CgkJCWNvbnN0IHggPSBsICsgKCBiYXJXaWR0aCAqIGkgKSArICggYmFyU3BhY2luZyAqIGkgKSArICggYmFyU3BhY2luZyAvIDIgKTsKCQkJcmV0dXJuIHg7CgkJfSwKCQlnZXRZKCBoZWlnaHQgKSB7CgkJCWNvbnN0IHsgYWgsIHQgfSA9IHRoaXM7CgkJCXJldHVybiBhaCArIHQgLSBoZWlnaHQ7CgkJfSwKCQlnZXRUZXh0WCggaSApIHsKCQkJY29uc3QgewoJCQkJbCwKCQkJCWJhcldpZHRoLAoJCQkJYmFyU3BhY2luZwoJCQl9ID0gdGhpczsKCQkJcmV0dXJuICggbCArICggYmFyV2lkdGggKiBpICkgKyAoIGJhclNwYWNpbmcgKiBpICkgKyAoIGJhcldpZHRoIC8gMiApICkgKyAoIGJhclNwYWNpbmcgLyAyICk7CgkJfSwKCQlnZXRIZWlnaHQoIHZhbHVlICkgewoJCQljb25zdCB2YWx1ZXMgPSB0aGlzLmNoYXJ0LmRhdGEubWFwKCBlbnRyeSA9PiBlbnRyeS52YWx1ZSApOwoJCQljb25zdCB7IGVuZCB9ID0gdGhpcy5nZXREYXRhUmFuZ2UoIHZhbHVlcywgZmFsc2UgKTsKCgkJCS8vICsgdGhpcyBhc3N1bWVzIHRoYXQgdGhlIGJvdHRvbSBvZiB0aGUgcmFuZ2UKCQkJLy8gKyBpcyBhbHdheXMgemVybwoJCQlyZXR1cm4gKCB2YWx1ZSAvIGVuZCApICogdGhpcy5haDsKCQl9CgoJfQp9Owo="},{"version":3,"sources":["InsectBarChart.vue"],"names":[],"mappings":";;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA","file":"InsectBarChart.vue","sourceRoot":"src/components/charts","sourcesContent":["<template lang='pug'>\n.chart\n\tsvg(ref='svg')\n</template>\n\n<script>\n/* eslint-disable*/\nimport formatNumber from '@/lib/utils/formatNumber';\nimport colors from '@/assets/js/colors';\nimport * as d3 from 'd3';\nimport BaseChart from './BaseChart';\nimport ChartLegend from '../ChartLegend';\n\nexport default {\n\tname    : 'quality-bar-chart',\n\textends : BaseChart,\n\tprops   : {\n\t\tchart : {\n\t\t\ttype    : Object,\n\t\t\tdefault : () => ( {\n\t\t\t\tlabel     : 'Pounds Produced in Fake Data',\n\t\t\t\tupdatedAt : new Date(),\n\t\t\t\tdata      : [{\n\t\t\t\t\tvalue : 220,\n\t\t\t\t\tlabel : 'All Fields',\n\t\t\t\t\tcolor : '#E5BF11',\n\t\t\t\t}],\n\t\t\t} ),\n\t\t},\n\t\toptions : {\n\t\t\ttype    : Object,\n\t\t\tdefault : () => ( {\n\t\t\t\thasBarLabels : true\n\t\t\t} )\n\t\t}\n\t},\n\tdata : () => ( {\n\t\tbarLabelHeight  : 30,\n\t\tbarLabelSpacing : 5\n\t} ),\n\tcomponents : {\n\t\tChartLegend\n\t},\n\n\tcomputed : {\n\t\tbarWidth() {\n\t\t\tconst { aw } = this;\n\t\t\treturn 50;\n\t\t\t// return Math.min( aw / this.chart.data.length, 30 );\n\t\t},\n\t\tbarSpacing() {\n\t\t\tconst { barWidth, data, aw } = this;\n\t\t\t// console.log( barWidth );\n\t\t\treturn ( aw - ( barWidth * this.chart.data.length ) ) / this.chart.data.length;\n\t\t},\n\t\tlabelTextSize() {\n\t\t\treturn this.barWidth * 0.75;\n\t\t}\n\t},\n\tmounted() {\n\t\t// console.log('mounted BarChart');\n\t\tthis.init( this.$refs.svg );\n\t},\n\tmethods : {\n\t\tdraw() {\n\t\t\tthis.updateDims( {\n\t\t\t\tl : 5,\n\t\t\t\tr : 5,\n\t\t\t\tt : 30\n\t\t\t} );\n\t\t\tconst { values } = this.chart.data.map( entry => entry.label );\n\t\t\tconst yValues = this.chart.data.map( entry => entry.value );\n\t\t\t// const sum = Object.keys( values ).reduce( ( total, key ) => total + values[key], 0 );\n\t\t\tconst sum = this.getDataRange( yValues, false ).end;\n\t\t\t// const yValues = this.chart.data[0].map( datum => datum.value );\n\t\t\tconst range   = { start : 0, end : sum };\n\n\t\t\tif ( this.hasBarLabels ) {\n\t\t\t\tthis.updateDims( {\n\t\t\t\t\tt : this.t + this.barLabelHeight + this.barLabelSpacing\n\t\t\t\t} );\n\t\t\t}\n\t\t\t// draw y-axis labels\n\n\t\t\tconst yAxisData = this.drawAxisIndicators( {\n\t\t\t\taxis           : 'y-right',\n\t\t\t\ttransformLabel : text => formatNumber( text ),\n\t\t\t\tlines          : {\n\t\t\t\t\tnumberOfIndicators         : 6,\n\t\t\t\t\tspaceBetweenLabelsAndLines : 10,\n\t\t\t\t},\n\t\t\t\tcolor : colors.colorPrimary,\n\t\t\t\tdifferentFirstAndLastLabels: false,\n\t\t\t\trange,\n\t\t\t} );\n\n\t\t\t// console.log( yAxisData );\n\t\t\t// draw x-axis labels\n\t\t\tconst xAxisData = this.drawAxisIndicators( {\n\t\t\t\taxis                       : 'x-bottom',\n\t\t\t\tvalues                     : this.chart.data,\n\t\t\t\tspaceBetweenLabelsAndChart : 10,\n\t\t\t\tlabelStyle                 : [\n\t\t\t\t\t['font-size', '14px'],\n\t\t\t\t\t['font-weight', '700'],\n\t\t\t\t\t['font-family', '\"Manjari\", sans-serif'],\n\t\t\t\t],\n\t\t\t} );\n\t\t\t// Compute the position and size of the bars\n\t\t\tconst barData   = this.newComputeBarData( );\n\t\t\tconst barGroups = this.newDrawBars( barData );\n\n\t\t\tthis.drawBarLabels( barGroups );\n\n\n\t\t},\n\n\t\tnewComputeBarData( ) {\n\t\t\tconst values = this.chart.data.map( entry => entry.value );\n\t\t\tconst { end } = this.getDataRange( values, false );\n\t\t\tconst sum = this.chart.data.reduce( ( total, entry ) => total + entry.value, 0 );\n\t\t\treturn this.chart.data.map( ( entry, i ) => {\n\t\t\t\tconst { value } = entry;\n\t\t\t\tconst height = ( value / end ) * this.ah;\n\t\t\t\tconst y = this.t + ( this.ah - height );\n\t\t\t\treturn {\n\t\t\t\t\twidth : this.barWidth,\n\t\t\t\t\tcolor : entry.color,\n\t\t\t\t\tx     : this.getX( i ),\n\t\t\t\t\t// x     : this.l + xDims[i].x,\n\t\t\t\t\tlabel : entry.label,\n\t\t\t\t\tvalue : entry.value,\n\t\t\t\t\ty,\n\t\t\t\t\theight\n\t\t\t\t};\n\t\t\t} );\n\t\t},\n\t\tnewDrawXaxis( barGroups ) {\n\t\t\tconst xAxisLabels = barGroups\n\t\t\t\t.append( 'text' )\n\t\t\t\t.attr( 'class', 'x-axis-labels' )\n\t\t\t\t.attr( 'x', ( d, i ) => this.getTextX( i ) )\n\t\t\t\t.attr( 'y', this.t + this.ah )\n\t\t\t\t.attr( 'text-anchor', 'middle' )\n\t\t\t\t.attr( 'dominant-baseline', 'start' )\n\t\t\t\t.style( 'font-size', '12px' )\n\t\t\t\t.text( d => d.label );\n\t\t\tthis.changeWithMode( {\n\t\t\t\tnodes   : xAxisLabels,\n\t\t\t\toptions : {\n\t\t\t\t\tday : {\n\t\t\t\t\t\tstyle : [\n\t\t\t\t\t\t\t['fill', colors.grey],\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t\tnight : {\n\t\t\t\t\t\tstyle : [\n\t\t\t\t\t\t\t['fill', colors.white],\n\t\t\t\t\t\t],\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t} );\n\t\t\tconst barLabelNodes = barGroups.selectAll( '.x-axis-labels' );\n\t\t\tconst barLabelWidths = Array.from( barLabelNodes._groups[0] ).map( a => a.getBBox().height );\n\t\t\tconst biggestBarLabel = Math.max( ...barLabelWidths );\n\t\t\tconst spaceBetweenBarAndXAxis = 2;\n\t\t\tthis.updateDims( {\n\t\t\t\tb : biggestBarLabel + spaceBetweenBarAndXAxis\n\t\t\t} );\n\t\t\treturn xAxisLabels;\n\t\t},\n\t\tnewDrawBars( barData ) {\n\t\t\tconst barGroups = this.canvas.selectAll( `bars-${this.id}` )\n\t\t\t\t.data( barData )\n\t\t\t\t.enter()\n\t\t\t\t.append( 'g' );\n\n\t\t\tbarGroups\n\t\t\t\t.append( 'rect' )\n\t\t\t\t.attr( 'x', d => d.x )\n\t\t\t\t.attr( 'y', d => d.y )\n\t\t\t\t// .attr( 'fill', d => d.color )\n\t\t\t\t.attr( 'fill', d => d.color )\n\t\t\t\t.attr( 'height', d => d.height )\n\t\t\t\t.attr( 'width', d => d.width )\n\t\t\t\t.attr( 'stroke', d => d.color )\n\t\t\t\t.attr( 'opacity', 0.8 )\n\t\t\t\t.attr( 'stroke-width', d => '2' )\n\t\t\t\t.attr('rx', '0')\n\t\t\t\t.attr( 'class', `bar-${this.id} translate-${this.id}` );\n\n\t\t\tconst roundToNearestMultipleOfEight = num => Math.ceil( Math.ceil( num ) / 8 ) * 8;\n\t\t\treturn barGroups;\n\t\t},\n\n\n\t\tdrawBarLabels( barGroups ) {\n\t\t\tconst barLabelGroups = barGroups\n\t\t\t\t.append( 'g' );\n\t\t\tconst textLabels = barLabelGroups.append( 'text' )\n\t\t\t\t.attr( 'x', ( d, i ) => this.getTextX( i )-90 )\n\t\t\t\t.attr( 'y', ( d ) => {\n\t\t\t\t\tconst height = this.getHeight( d.value );\n\t\t\t\t\tconst y = this.getY( height );\n\t\t\t\t\treturn y - ( ( this.barLabelHeight / 2 ) + this.barLabelSpacing );\n\t\t\t\t} )\n\t\t\t\t.attr( 'class', 'bar-value' )\n\t\t\t\t.attr( 'text-anchor', 'middle' )\n\t\t\t\t.attr( 'dominant-baseline', 'middle' )\n\t\t\t\t.style( 'fill', d => d.color )\n\t\t\t\t.style( 'font-weight', 'bold' )\n\t\t\t\t.style( 'font-family', 'Roboto Slab' )\n\t\t\t\t.style( 'font-size', `${this.labelTextSize}px` )\n\t\t\t\t.text( d => formatNumber(d.value) );\n\n\t\t\tbarLabelGroups.append( 'text' )\n\t\t\t\t.attr( 'x', ( d, i ) => this.getTextX( i )-90 )\n\t\t\t\t.attr( 'y', ( d ) => {\n\t\t\t\t\tconst height = this.getHeight( d.value );\n\t\t\t\t\tconst y = this.getY( height );\n\t\t\t\t\treturn y - ( ( this.barLabelHeight / 2 ) + this.barLabelSpacing )+30;\n\t\t\t\t} )\n\t\t\t\t.attr( 'class', 'bar-value' )\n\t\t\t\t.attr( 'text-anchor', 'middle' )\n\t\t\t\t.attr( 'dominant-baseline', 'middle' )\n\t\t\t\t.style( 'fill', colors.colorPrimary )\n\t\t\t\t.style( 'font-family', 'Roboto Slab' )\n\t\t\t\t.style( 'font-size', `20px` )\n\t\t\t\t.text( d => \"Pounds\" );\n\n\t\t\tbarLabelGroups.append( 'text' )\n\t\t\t\t.attr( 'x', ( d, i ) => this.getTextX( i )-90 )\n\t\t\t\t.attr( 'y', ( d ) => {\n\t\t\t\t\tconst height = this.getHeight( d.value );\n\t\t\t\t\tconst y = this.getY( height );\n\t\t\t\t\treturn y - ( ( this.barLabelHeight / 2 ) + this.barLabelSpacing )+50;\n\t\t\t\t} )\n\t\t\t\t.attr( 'class', 'bar-value' )\n\t\t\t\t.attr( 'text-anchor', 'middle' )\n\t\t\t\t.attr( 'dominant-baseline', 'middle' )\n\t\t\t\t.style( 'fill', colors.colorPrimary )\n\t\t\t\t.style( 'font-family', 'Roboto Slab' )\n\t\t\t\t.style( 'font-size', `20px` )\n\t\t\t\t.text( d => \"damaged\" );\n\n\t\t\tbarLabelGroups.append( 'text' )\n\t\t\t\t.attr( 'x', ( d, i ) => this.getTextX( i )-90 )\n\t\t\t\t.attr( 'y', ( d ) => {\n\t\t\t\t\tconst height = this.getHeight( d.value );\n\t\t\t\t\tconst y = this.getY( height );\n\t\t\t\t\treturn y - ( ( this.barLabelHeight / 2 ) + this.barLabelSpacing )+70;\n\t\t\t\t} )\n\t\t\t\t.attr( 'class', 'bar-value' )\n\t\t\t\t.attr( 'text-anchor', 'middle' )\n\t\t\t\t.attr( 'dominant-baseline', 'middle' )\n\t\t\t\t.style( 'fill', colors.colorPrimary )\n\t\t\t\t.style( 'font-family', 'Roboto Slab' )\n\t\t\t\t.style( 'font-size', `20px` )\n\t\t\t\t.text( \"in 2020\" );\n\n\n\n\n\t\t\tconst textDims = Array.from(\n\t\t\t\ttextLabels._groups[0]\n\t\t\t).map(\n\t\t\t\ttext => d3.select( text )\n\t\t\t\t\t.node()\n\t\t\t\t\t.getBBox()\n\t\t\t);\n\n\t\t},\n\t\tdrawXAxisIndicators( options ) {\n\t\t\tconst {\n\t\t\t\taxis,\n\t\t\t\tvalues,\n\t\t\t\tspaceBetweenLabelsAndChart,\n\t\t\t\tlabelStyle,\n\t\t\t} = options;\n\n\t\t\tconst getX = ( i ) => {\n\t\t\t\tconst { aw, l } = this;\n\n\t\t\t\treturn l + ( ( aw / ( values.length + 1 ) ) * ( i + 1 ) );\n\t\t\t};\n\n\t\t\tconst xAxisData = values.map( ( datum, i ) => {\n\n\t\t\t\tconst y = () => ( ( axis === 'x-top' ) ? this.t : this.t + this.ah );\n\t\t\t\tconst x = () => getX( i );\n\t\t\t\treturn {\n\t\t\t\t\t...datum,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\ttextAnchor       : 'middle',\n\t\t\t\t\tdominantBaseline : ( axis === 'x-top' ) ? 'text-before-edge' : 'text-after-edge',\n\t\t\t\t};\n\t\t\t} );\n\n\t\t\tconst xAxisLabels = this.canvas\n\t\t\t\t.selectAll( 'x-axis-labels axis-label' )\n\t\t\t\t.data( xAxisData )\n\t\t\t\t.enter()\n\t\t\t\t.append( 'text' )\n\t\t\t\t.attr( 'text-anchor', d => d.textAnchor )\n\t\t\t\t.attr( 'x', ( d, i ) => this.getTextX( i ) )\n\t\t\t\t.attr( 'y', d => d.y() )\n\t\t\t\t.attr( 'dominant-baseline', d => d.dominantBaseline )\n\t\t\t\t.style( 'fill', colors.colorPrimary )\n\t\t\t\t.text( d => d.label );\n\n\t\t\tif ( labelStyle ) {\n\t\t\t\tthis.applyMethods( xAxisLabels, 'style', labelStyle );\n\t\t\t}\n\n\t\t\tconst xAxisLabelDims    = Array.from( xAxisLabels._groups[0] ).map( a => a.getBBox() );\n\t\t\tconst xAxisLabelHeights = xAxisLabelDims.map( a => a.height );\n\t\t\t// const xAxisLabelWidths  = xAxisLabelDims.map( a => a.width );\n\t\t\tconst biggestXAxisLabel = Math.max( ...xAxisLabelHeights );\n\n\t\t\tconst dims = ( () => {\n\t\t\t\tif ( axis === 'y-top' ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt : biggestXAxisLabel + spaceBetweenLabelsAndChart,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tb : biggestXAxisLabel + spaceBetweenLabelsAndChart,\n\t\t\t\t};\n\t\t\t} )();\n\n\t\t\tthis.updateDims( dims );\n\t\t\tthis.realignAxisLabels();\n\n\t\t\t// ? center texts as necessary\n\t\t\t// const totalTextSpace = xAxisLabelWidths.reduce( ( sum, w ) => sum + w, 0 );\n\t\t\t// const leftOverSpace  = this.aw - totalTextSpace;\n\t\t\t// const spaceAround    = ( leftOverSpace / ( values.length + 1 ) );\n\n\t\t\treturn xAxisLabelDims;\n\n\t\t},\n\t\tgetX( i ) {\n\t\t\tconst {\n\t\t\t\tl,\n\t\t\t\tbarWidth,\n\t\t\t\tbarSpacing,\n\t\t\t} = this;\n\t\t\tconst x = l + ( barWidth * i ) + ( barSpacing * i ) + ( barSpacing / 2 );\n\t\t\treturn x;\n\t\t},\n\t\tgetY( height ) {\n\t\t\tconst { ah, t } = this;\n\t\t\treturn ah + t - height;\n\t\t},\n\t\tgetTextX( i ) {\n\t\t\tconst {\n\t\t\t\tl,\n\t\t\t\tbarWidth,\n\t\t\t\tbarSpacing\n\t\t\t} = this;\n\t\t\treturn ( l + ( barWidth * i ) + ( barSpacing * i ) + ( barWidth / 2 ) ) + ( barSpacing / 2 );\n\t\t},\n\t\tgetHeight( value ) {\n\t\t\tconst values = this.chart.data.map( entry => entry.value );\n\t\t\tconst { end } = this.getDataRange( values, false );\n\n\t\t\t// + this assumes that the bottom of the range\n\t\t\t// + is always zero\n\t\t\treturn ( value / end ) * this.ah;\n\t\t}\n\n\t}\n};\n</script>\n\n<style lang='scss'>\n\t.chart{\n\t\theight: 50%;\n\t\twidth: 100%;\n\t\tsvg {\n\t\t// flex: 2 2 0\n\t\tposition: relative;\n\t\theight: 100%;\n\t\twidth: 100%;\n\t\tborder: 0px;\n\t\t}\n\t}\n\t// .chart{\n\t// \tdisplay: flex;\n\t// \talign-items: stretch;\n\t// \twidth: 100%;\n\t// \theight: 200px;\n\t// \tpadding:0;\n\t// \tsvg {\n\t// \t// flex: 2 2 0\n\t// \tposition: relative;\n\t// \theight: 100%;\n\t// \twidth: 100%;\n\t// \tborder: 0px;;\n\t// \t}\n\t// }\n\n</style>\n"]}]}