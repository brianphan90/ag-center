{"remainingRequest":"/Users/brianphan/jets/kf-grower-portal/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/brianphan/jets/kf-grower-portal/src/components/charts/StackedBarChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/brianphan/jets/kf-grower-portal/src/components/charts/StackedBarChart.vue","mtime":1617753126833},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBmb3JtYXROdW1iZXIgZnJvbSAnQC9saWIvdXRpbHMvZm9ybWF0TnVtYmVyJzsKaW1wb3J0IGNvbG9ycyBmcm9tICdAL2Fzc2V0cy9qcy9jb2xvcnMnOwppbXBvcnQgQmFzZUNoYXJ0IGZyb20gJy4vQmFzZUNoYXJ0JzsKaW1wb3J0IENoYXJ0TGVnZW5kIGZyb20gJy4uL0NoYXJ0TGVnZW5kJzsKCmV4cG9ydCBkZWZhdWx0IHsKCW5hbWUgICAgICAgOiAnc3RhY2tlZC1iYXItY2hhcnQnLAoJZXh0ZW5kcyAgICA6IEJhc2VDaGFydCwKCWNvbXBvbmVudHMgOiB7CgkJQ2hhcnRMZWdlbmQKCX0sCglwcm9wcyA6IHsKCQljaGFydCA6IHsKCQkJdHlwZSA6IE9iamVjdCwKCQl9LAoJCWxlZ2VuZCA6IHsKCQkJdHlwZSA6IE9iamVjdCwKCgkJfQoJfSwKCglkYXRhIDogKCkgPT4gKCB7CgkJLy8gbm90aGluZyB5ZXQKCX0gKSwKCWNvbXB1dGVkIDogewoJCWJhcldpZHRoKCkgewoJCQljb25zdCB7IGF3IH0gPSB0aGlzOwoJCQlyZXR1cm4gTWF0aC5taW4oIGF3IC8gdGhpcy5jaGFydC5kYXRhLmxlbmd0aCwgNzAgKTsKCQl9LAoJCWJhclNwYWNpbmcoKSB7CgkJCWNvbnN0IHsgYmFyV2lkdGgsIGF3IH0gPSB0aGlzOwoJCQljb25zb2xlLmxvZyggYmFyV2lkdGggKTsKCQkJcmV0dXJuICggYXcgLSAoIGJhcldpZHRoICogdGhpcy5jaGFydC5kYXRhLmxlbmd0aCApICkgLyB0aGlzLmNoYXJ0LmRhdGEubGVuZ3RoOwoJCX0sCgkJbGFiZWxUZXh0U2l6ZSgpIHsKCQkJcmV0dXJuIHRoaXMuYmFyV2lkdGggKiAwLjU1OwoJCX0KCX0sCgltb3VudGVkKCkgewoJCXRoaXMuaW5pdCggdGhpcy4kcmVmcy5zdmcgKTsKCX0sCgltZXRob2RzIDogewoJCWRyYXcoKSB7CgkJCWNvbnN0IHsgdmFsdWVzIH0gPSB0aGlzLmNoYXJ0LmRhdGFbMF07CgkJCWNvbnN0IHlWYWx1ZXMgPSBPYmplY3Qua2V5cyggdmFsdWVzICkubWFwKCBrZXkgPT4gdmFsdWVzW2tleV0gKTsKCQkJY29uc3Qgc3VtID0gT2JqZWN0LmtleXMoIHZhbHVlcyApLnJlZHVjZSggKCB0b3RhbCwga2V5ICkgPT4gdG90YWwgKyB2YWx1ZXNba2V5XSwgMCApOwoJCQkvLyBjb25zdCB5VmFsdWVzID0gdGhpcy5jaGFydC5kYXRhWzBdLm1hcCggZGF0dW0gPT4gZGF0dW0udmFsdWUgKTsKCQkJY29uc3QgcmFuZ2UgICA9IHsgc3RhcnQgOiAwLCBlbmQgOiBzdW0gfTsKCgkJCS8vIGRyYXcgeS1heGlzIGxhYmVscwoJCQljb25zdCB5QXhpc0RhdGEgPSB0aGlzLmRyYXdBeGlzSW5kaWNhdG9ycyggewoJCQkJYXhpcyAgICAgICAgICAgOiAneS1yaWdodCcsCgkJCQl0cmFuc2Zvcm1MYWJlbCA6IHRleHQgPT4gZm9ybWF0TnVtYmVyKCB0ZXh0ICksCgkJCQlsaW5lcyAgICAgICAgICA6IHsKCQkJCQludW1iZXJPZkluZGljYXRvcnMgICAgICAgICA6IDYsCgkJCQkJc3BhY2VCZXR3ZWVuTGFiZWxzQW5kTGluZXMgOiAxMCwKCQkJCX0sCgkJCQljb2xvciA6IGNvbG9ycy5jb2xvclByaW1hcnksCgkJCQlyYW5nZSwKCQkJfSApOwoJCQkvLyBjb25zb2xlLmxvZyggeUF4aXNEYXRhICk7CgkJCS8vIGRyYXcgeC1heGlzIGxhYmVscwoJCQljb25zdCB4QXhpc0RhdGEgPSB0aGlzLmRyYXdBeGlzSW5kaWNhdG9ycyggewoJCQkJYXhpcyAgICAgICAgICAgICAgICAgICAgICAgOiAneC1ib3R0b20nLAoJCQkJdmFsdWVzICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmNoYXJ0LmRhdGEsCgkJCQlzcGFjZUJldHdlZW5MYWJlbHNBbmRDaGFydCA6IDEwLAoJCQkJbGFiZWxTdHlsZSAgICAgICAgICAgICAgICAgOiBbCgkJCQkJWydmb250LXNpemUnLCAnMTRweCddLAoJCQkJCVsnZm9udC13ZWlnaHQnLCAnNzAwJ10sCgkJCQkJWydmb250LWZhbWlseScsICciTWFuamFyaSIsIHNhbnMtc2VyaWYnXSwKCQkJCV0sCgkJCX0gKTsKCQkJLy8geEF4aXNEYXRhLmZvckVhY2goICggaXRlbSwga2V5ICkgPT4gY29uc29sZS5sb2coIGdldFgoIGtleSApICkgKTsKCQkJLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gYW5kIHNpemUgb2YgdGhlIGJhcnMKCQkJY29uc3QgYmFyRGF0YSAgID0gdGhpcy5teUNvbXB1dGVCYXJEYXRhKCB4QXhpc0RhdGEgKTsKCQkJLy8gY29uc29sZS5sb2coIGJhckRhdGEgKTsKCQkJY29uc3QgYmFyR3JvdXBzID0gYmFyRGF0YS5tYXAoIHZhcmlldHkgPT4gdGhpcy5kcmF3QmFycyggdmFyaWV0eSApICk7CgkJCWNvbnNvbGUubG9nKCBiYXJHcm91cHMgKTsKCQkJLy8gYmFyR3JvdXBzLmZvckVhY2goIGdyb3VwaW5nID0+IGdyb3VwaW5nLl9ncm91cHNbMF0uZm9yRWFjaCggZyA9PiBjb25zb2xlLmxvZyggZy5fX2RhdGFfXy50ZXh0ICkgKSApOwoJCQliYXJHcm91cHMuZm9yRWFjaCggZ3JvdXBpbmcgPT4gdGhpcy5kcmF3QmFyTGFiZWxzKCBncm91cGluZyApICk7CgoJCX0sCgoJCS8vIHJlcGVhdCBmb3IgZWFjaCBpdGVtIGluIGRhdGEKCQlteUNvbXB1dGVCYXJEYXRhKCB4RGltcyApIHsKCQkJY29uc3QgdG90YWxEYXRhID0gdGhpcy5jaGFydC5kYXRhLm1hcCggKCBlbnRyeSwgaSApID0+IHsKCQkJCWNvbnN0IGJhcktleXMgPSBPYmplY3Qua2V5cyggZW50cnkudmFsdWVzICk7CgkJCQljb25zdCBzdW0gPSBiYXJLZXlzLnJlZHVjZSggKCB0b3RhbCwgaiApID0+IHRvdGFsICsgZW50cnkudmFsdWVzW2pdLCAwICk7CgkJCQlsZXQgcnVubmluZ1N1bSA9IDA7CgkJCQlyZXR1cm4gYmFyS2V5cy5tYXAoICgga2V5ICkgPT4gewoJCQkJLy8gZ2V0IHRoZSB2YWx1ZSBhbmQgdGhlIGhlaWdodAoJCQkJCWNvbnN0IHZhbHVlICA9IGVudHJ5LnZhbHVlc1trZXldOwoJCQkJCWNvbnN0IGhlaWdodCA9ICggdmFsdWUgLyBzdW0gKSAqIHRoaXMuYWg7CgkJCQkJLy8gZGV0ZXJtaW5lIHRoZSB5IHZhbHVlIGZvciB0aGUgYmFyCgkJCQkJY29uc3QgeSA9IHRoaXMudCArICggKCBydW5uaW5nU3VtIC8gc3VtICkgKiB0aGlzLmFoICk7CgkJCQkJLy8gYWRkIHRvIHJ1bm5pbmcgc3VtIHNvIHdlIGNhbgoJCQkJCS8vIGRvIHkgdmFsdWUgY2FsY3VsYXRpb25zCgkJCQkJcnVubmluZ1N1bSArPSB2YWx1ZTsKCQkJCQlyZXR1cm4gewoJCQkJCQl3aWR0aCA6IHRoaXMuYmFyV2lkdGgsIC8vIDMwcHggb24gZWFjaCBzaWRlCgkJCQkJCWNvbG9yIDogdGhpcy5sZWdlbmRba2V5XS5jb2xvciwKCQkJCQkJdGV4dCAgOiBmb3JtYXROdW1iZXIoIHZhbHVlICksCgkJCQkJCXggICAgIDogdGhpcy5nZXRYKCBpICksIC8vIDMwcHggdG8gdGhlIGxlZnQKCQkJCQkJeSwKCQkJCQkJaGVpZ2h0LAoJCQkJCX07CgkJCQl9ICk7CgkJCX0gKTsKCQkJcmV0dXJuIHRvdGFsRGF0YTsKCgkJfSwKCgkJZHJhd0JhcnMoIGJhckRhdGEgKSB7CgkJCS8vIERyYXcgdGhlIGJhcnMKCQkJY29uc3QgYmFyR3JvdXBzID0gdGhpcy5jYW52YXMuc2VsZWN0QWxsKCBgYmFycy0ke3RoaXMuaWR9YCApCgkJCQkuZGF0YSggYmFyRGF0YSApCgkJCQkuZW50ZXIoKQoJCQkJLmFwcGVuZCggJ2cnICk7CgkJCWJhckdyb3VwcwoJCQkJLmFwcGVuZCggJ3JlY3QnICkKCQkJCS5hdHRyKCAneCcsIGQgPT4gZC54ICkKCQkJCS5hdHRyKCAneScsIGQgPT4gZC55ICkKCQkJCS5hdHRyKCAnZmlsbCcsIGQgPT4gZC5jb2xvciApCgkJCQkuYXR0ciggJ29wYWNpdHknLCAwLjgwICkKCQkJCS5hdHRyKCAnaGVpZ2h0JywgZCA9PiBkLmhlaWdodCApCgkJCQkuYXR0ciggJ3dpZHRoJywgZCA9PiBkLndpZHRoICkKCQkJCS5hdHRyKCAnY2xhc3MnLCBgYmFyLSR7dGhpcy5pZH0gdHJhbnNsYXRlLSR7dGhpcy5pZH1gICk7CgoJCQlyZXR1cm4gYmFyR3JvdXBzOwoJCX0sCgkJZHJhd0JhckxhYmVscyggYmFyR3JvdXBzICkgewoJCQliYXJHcm91cHMKCQkJCS5hcHBlbmQoICd0ZXh0JyApCgkJCQkuYXR0ciggJ2NsYXNzJywgYHRleHQtbm9kZS0ke3RoaXMuaWR9IHRyYW5zbGF0ZS0ke3RoaXMuaWR9YCApCgkJCQkuYXR0ciggJ3gnLCBkID0+ICggZC54IC0gZC53aWR0aCAvIDggKSApIC8vIGNoYW5nZSBsYXRlciB0byBjYWxjdWxhdGVkIHZhbHVlCgkJCQkuYXR0ciggJ3knLCBkID0+ICggZC55ICsgKCBkLmhlaWdodCArIGQueSApICkgLyAyIC0gZC5oZWlnaHQgLyA0ICkKCQkJCS5hdHRyKCAnZmlsbCcsIGQgPT4gZC5jb2xvciApCgkJCQkuc3R5bGUoICdmb250LWZhbWlseScsICdCaXR0ZXInICkKCQkJCS5hdHRyKCAndGV4dC1hbmNob3InLCAnZW5kJyApCgkJCQkuYXR0ciggJ2RvbWluYW50LWJhc2VsaW5lJywgJ3RleHQtYmVmb3JlLWVkZ2UnICkKCQkJCS8vIC5zdHlsZSggJ29wYWNpdHknLCAwICkKCQkJCS50ZXh0KCBkID0+IGQudGV4dCApOwoJCX0sCgkJZHJhd1hBeGlzSW5kaWNhdG9ycyggb3B0aW9ucyApIHsKCQkJY29uc3QgewoJCQkJYXhpcywKCQkJCXZhbHVlcywKCQkJCXNwYWNlQmV0d2VlbkxhYmVsc0FuZENoYXJ0LAoJCQkJbGFiZWxTdHlsZSwKCQkJfSA9IG9wdGlvbnM7CgoJCQljb25zdCBnZXRYID0gKCBpICkgPT4gewoJCQkJY29uc3QgeyBhdywgbCB9ID0gdGhpczsKCgkJCQlyZXR1cm4gbCArICggKCBhdyAvICggdmFsdWVzLmxlbmd0aCArIDEgKSApICogKCBpICsgMSApICk7CgkJCX07CgoJCQljb25zdCB4QXhpc0RhdGEgPSB2YWx1ZXMubWFwKCAoIGRhdHVtLCBpICkgPT4gewoJCQkJY29uc3QgeSA9ICgpID0+ICggKCBheGlzID09PSAneC10b3AnICkgPyB0aGlzLnQgOiB0aGlzLnQgKyB0aGlzLmFoICk7CgkJCQljb25zdCB4ID0gKCkgPT4gZ2V0WCggaSApOwoKCQkJCXJldHVybiB7CgkJCQkJLi4uZGF0dW0sCgkJCQkJeCwKCQkJCQl5LAoJCQkJCXRleHRBbmNob3IgICAgICAgOiAnbWlkZGxlJywKCQkJCQlkb21pbmFudEJhc2VsaW5lIDogKCBheGlzID09PSAneC10b3AnICkgPyAndGV4dC1iZWZvcmUtZWRnZScgOiAndGV4dC1hZnRlci1lZGdlJywKCQkJCX07CgkJCX0gKTsKCgkJCWNvbnN0IHhBeGlzTGFiZWxzID0gdGhpcy5jYW52YXMKCQkJCS5zZWxlY3RBbGwoICd4LWF4aXMtbGFiZWxzIGF4aXMtbGFiZWwnICkKCQkJCS5kYXRhKCB4QXhpc0RhdGEgKQoJCQkJLmVudGVyKCkKCQkJCS5hcHBlbmQoICd0ZXh0JyApCgkJCQkuYXR0ciggJ3RleHQtYW5jaG9yJywgZCA9PiBkLnRleHRBbmNob3IgKQoJCQkJLmF0dHIoICd4JywgZCA9PiBkLngoKSApCgkJCQkuYXR0ciggJ3knLCBkID0+IGQueSgpICkKCQkJCS5hdHRyKCAnZG9taW5hbnQtYmFzZWxpbmUnLCBkID0+IGQuZG9taW5hbnRCYXNlbGluZSApCgkJCQkuc3R5bGUoICdmaWxsJywgZCA9PiBkLmNvbG9yICkKCQkJCS50ZXh0KCBkID0+IGQubGFiZWwgKTsKCgkJCWlmICggbGFiZWxTdHlsZSApIHsKCQkJCXRoaXMuYXBwbHlNZXRob2RzKCB4QXhpc0xhYmVscywgJ3N0eWxlJywgbGFiZWxTdHlsZSApOwoJCQl9CgoJCQljb25zdCB4QXhpc0xhYmVsRGltcyAgICA9IEFycmF5LmZyb20oIHhBeGlzTGFiZWxzLl9ncm91cHNbMF0gKS5tYXAoIGEgPT4gYS5nZXRCQm94KCkgKTsKCQkJY29uc3QgeEF4aXNMYWJlbEhlaWdodHMgPSB4QXhpc0xhYmVsRGltcy5tYXAoIGEgPT4gYS5oZWlnaHQgKTsKCQkJLy8gY29uc3QgeEF4aXNMYWJlbFdpZHRocyAgPSB4QXhpc0xhYmVsRGltcy5tYXAoIGEgPT4gYS53aWR0aCApOwoJCQljb25zdCBiaWdnZXN0WEF4aXNMYWJlbCA9IE1hdGgubWF4KCAuLi54QXhpc0xhYmVsSGVpZ2h0cyApOwoKCQkJY29uc3QgZGltcyA9ICggKCkgPT4gewoJCQkJaWYgKCBheGlzID09PSAneS10b3AnICkgewoJCQkJCXJldHVybiB7CgkJCQkJCXQgOiBiaWdnZXN0WEF4aXNMYWJlbCArIHNwYWNlQmV0d2VlbkxhYmVsc0FuZENoYXJ0LAoJCQkJCX07CgkJCQl9CgoJCQkJcmV0dXJuIHsKCQkJCQliIDogYmlnZ2VzdFhBeGlzTGFiZWwgKyBzcGFjZUJldHdlZW5MYWJlbHNBbmRDaGFydCwKCQkJCX07CgkJCX0gKSgpOwoKCQkJdGhpcy51cGRhdGVEaW1zKCBkaW1zICk7CgkJCXRoaXMucmVhbGlnbkF4aXNMYWJlbHMoKTsKCgkJCS8vID8gY2VudGVyIHRleHRzIGFzIG5lY2Vzc2FyeQoJCQkvLyBjb25zdCB0b3RhbFRleHRTcGFjZSA9IHhBeGlzTGFiZWxXaWR0aHMucmVkdWNlKCAoIHN1bSwgdyApID0+IHN1bSArIHcsIDAgKTsKCQkJLy8gY29uc3QgbGVmdE92ZXJTcGFjZSAgPSB0aGlzLmF3IC0gdG90YWxUZXh0U3BhY2U7CgkJCS8vIGNvbnN0IHNwYWNlQXJvdW5kICAgID0gKCBsZWZ0T3ZlclNwYWNlIC8gKCB2YWx1ZXMubGVuZ3RoICsgMSApICk7CgoJCQlyZXR1cm4geEF4aXNMYWJlbERpbXM7CgoJCX0sCgkJZ2V0WCggaSApIHsKCQkJY29uc3QgewoJCQkJbCwKCQkJCWJhcldpZHRoLAoJCQkJYmFyU3BhY2luZywKCQkJfSA9IHRoaXM7CgkJCWNvbnN0IHggPSBsICsgKCBiYXJXaWR0aCAqIGkgKSArICggYmFyU3BhY2luZyAqIGkgKSArICggYmFyU3BhY2luZyAvIDIgKTsKCQkJcmV0dXJuIHg7CgkJfSwKCgl9Cn07Cg=="},{"version":3,"sources":["StackedBarChart.vue"],"names":[],"mappings":";;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA","file":"StackedBarChart.vue","sourceRoot":"src/components/charts","sourcesContent":["<template lang='pug'>\n\t.chart\n\t\tsvg(ref='svg')\n\t\t.legend\n\t\t\tchart-legend(:legend='this.legend'\n\t\t\tcolumns=1)\n</template>\n\n<script>\nimport formatNumber from '@/lib/utils/formatNumber';\nimport colors from '@/assets/js/colors';\nimport BaseChart from './BaseChart';\nimport ChartLegend from '../ChartLegend';\n\nexport default {\n\tname       : 'stacked-bar-chart',\n\textends    : BaseChart,\n\tcomponents : {\n\t\tChartLegend\n\t},\n\tprops : {\n\t\tchart : {\n\t\t\ttype : Object,\n\t\t},\n\t\tlegend : {\n\t\t\ttype : Object,\n\n\t\t}\n\t},\n\n\tdata : () => ( {\n\t\t// nothing yet\n\t} ),\n\tcomputed : {\n\t\tbarWidth() {\n\t\t\tconst { aw } = this;\n\t\t\treturn Math.min( aw / this.chart.data.length, 70 );\n\t\t},\n\t\tbarSpacing() {\n\t\t\tconst { barWidth, aw } = this;\n\t\t\tconsole.log( barWidth );\n\t\t\treturn ( aw - ( barWidth * this.chart.data.length ) ) / this.chart.data.length;\n\t\t},\n\t\tlabelTextSize() {\n\t\t\treturn this.barWidth * 0.55;\n\t\t}\n\t},\n\tmounted() {\n\t\tthis.init( this.$refs.svg );\n\t},\n\tmethods : {\n\t\tdraw() {\n\t\t\tconst { values } = this.chart.data[0];\n\t\t\tconst yValues = Object.keys( values ).map( key => values[key] );\n\t\t\tconst sum = Object.keys( values ).reduce( ( total, key ) => total + values[key], 0 );\n\t\t\t// const yValues = this.chart.data[0].map( datum => datum.value );\n\t\t\tconst range   = { start : 0, end : sum };\n\n\t\t\t// draw y-axis labels\n\t\t\tconst yAxisData = this.drawAxisIndicators( {\n\t\t\t\taxis           : 'y-right',\n\t\t\t\ttransformLabel : text => formatNumber( text ),\n\t\t\t\tlines          : {\n\t\t\t\t\tnumberOfIndicators         : 6,\n\t\t\t\t\tspaceBetweenLabelsAndLines : 10,\n\t\t\t\t},\n\t\t\t\tcolor : colors.colorPrimary,\n\t\t\t\trange,\n\t\t\t} );\n\t\t\t// console.log( yAxisData );\n\t\t\t// draw x-axis labels\n\t\t\tconst xAxisData = this.drawAxisIndicators( {\n\t\t\t\taxis                       : 'x-bottom',\n\t\t\t\tvalues                     : this.chart.data,\n\t\t\t\tspaceBetweenLabelsAndChart : 10,\n\t\t\t\tlabelStyle                 : [\n\t\t\t\t\t['font-size', '14px'],\n\t\t\t\t\t['font-weight', '700'],\n\t\t\t\t\t['font-family', '\"Manjari\", sans-serif'],\n\t\t\t\t],\n\t\t\t} );\n\t\t\t// xAxisData.forEach( ( item, key ) => console.log( getX( key ) ) );\n\t\t\t// Compute the position and size of the bars\n\t\t\tconst barData   = this.myComputeBarData( xAxisData );\n\t\t\t// console.log( barData );\n\t\t\tconst barGroups = barData.map( variety => this.drawBars( variety ) );\n\t\t\tconsole.log( barGroups );\n\t\t\t// barGroups.forEach( grouping => grouping._groups[0].forEach( g => console.log( g.__data__.text ) ) );\n\t\t\tbarGroups.forEach( grouping => this.drawBarLabels( grouping ) );\n\n\t\t},\n\n\t\t// repeat for each item in data\n\t\tmyComputeBarData( xDims ) {\n\t\t\tconst totalData = this.chart.data.map( ( entry, i ) => {\n\t\t\t\tconst barKeys = Object.keys( entry.values );\n\t\t\t\tconst sum = barKeys.reduce( ( total, j ) => total + entry.values[j], 0 );\n\t\t\t\tlet runningSum = 0;\n\t\t\t\treturn barKeys.map( ( key ) => {\n\t\t\t\t// get the value and the height\n\t\t\t\t\tconst value  = entry.values[key];\n\t\t\t\t\tconst height = ( value / sum ) * this.ah;\n\t\t\t\t\t// determine the y value for the bar\n\t\t\t\t\tconst y = this.t + ( ( runningSum / sum ) * this.ah );\n\t\t\t\t\t// add to running sum so we can\n\t\t\t\t\t// do y value calculations\n\t\t\t\t\trunningSum += value;\n\t\t\t\t\treturn {\n\t\t\t\t\t\twidth : this.barWidth, // 30px on each side\n\t\t\t\t\t\tcolor : this.legend[key].color,\n\t\t\t\t\t\ttext  : formatNumber( value ),\n\t\t\t\t\t\tx     : this.getX( i ), // 30px to the left\n\t\t\t\t\t\ty,\n\t\t\t\t\t\theight,\n\t\t\t\t\t};\n\t\t\t\t} );\n\t\t\t} );\n\t\t\treturn totalData;\n\n\t\t},\n\n\t\tdrawBars( barData ) {\n\t\t\t// Draw the bars\n\t\t\tconst barGroups = this.canvas.selectAll( `bars-${this.id}` )\n\t\t\t\t.data( barData )\n\t\t\t\t.enter()\n\t\t\t\t.append( 'g' );\n\t\t\tbarGroups\n\t\t\t\t.append( 'rect' )\n\t\t\t\t.attr( 'x', d => d.x )\n\t\t\t\t.attr( 'y', d => d.y )\n\t\t\t\t.attr( 'fill', d => d.color )\n\t\t\t\t.attr( 'opacity', 0.80 )\n\t\t\t\t.attr( 'height', d => d.height )\n\t\t\t\t.attr( 'width', d => d.width )\n\t\t\t\t.attr( 'class', `bar-${this.id} translate-${this.id}` );\n\n\t\t\treturn barGroups;\n\t\t},\n\t\tdrawBarLabels( barGroups ) {\n\t\t\tbarGroups\n\t\t\t\t.append( 'text' )\n\t\t\t\t.attr( 'class', `text-node-${this.id} translate-${this.id}` )\n\t\t\t\t.attr( 'x', d => ( d.x - d.width / 8 ) ) // change later to calculated value\n\t\t\t\t.attr( 'y', d => ( d.y + ( d.height + d.y ) ) / 2 - d.height / 4 )\n\t\t\t\t.attr( 'fill', d => d.color )\n\t\t\t\t.style( 'font-family', 'Bitter' )\n\t\t\t\t.attr( 'text-anchor', 'end' )\n\t\t\t\t.attr( 'dominant-baseline', 'text-before-edge' )\n\t\t\t\t// .style( 'opacity', 0 )\n\t\t\t\t.text( d => d.text );\n\t\t},\n\t\tdrawXAxisIndicators( options ) {\n\t\t\tconst {\n\t\t\t\taxis,\n\t\t\t\tvalues,\n\t\t\t\tspaceBetweenLabelsAndChart,\n\t\t\t\tlabelStyle,\n\t\t\t} = options;\n\n\t\t\tconst getX = ( i ) => {\n\t\t\t\tconst { aw, l } = this;\n\n\t\t\t\treturn l + ( ( aw / ( values.length + 1 ) ) * ( i + 1 ) );\n\t\t\t};\n\n\t\t\tconst xAxisData = values.map( ( datum, i ) => {\n\t\t\t\tconst y = () => ( ( axis === 'x-top' ) ? this.t : this.t + this.ah );\n\t\t\t\tconst x = () => getX( i );\n\n\t\t\t\treturn {\n\t\t\t\t\t...datum,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\ttextAnchor       : 'middle',\n\t\t\t\t\tdominantBaseline : ( axis === 'x-top' ) ? 'text-before-edge' : 'text-after-edge',\n\t\t\t\t};\n\t\t\t} );\n\n\t\t\tconst xAxisLabels = this.canvas\n\t\t\t\t.selectAll( 'x-axis-labels axis-label' )\n\t\t\t\t.data( xAxisData )\n\t\t\t\t.enter()\n\t\t\t\t.append( 'text' )\n\t\t\t\t.attr( 'text-anchor', d => d.textAnchor )\n\t\t\t\t.attr( 'x', d => d.x() )\n\t\t\t\t.attr( 'y', d => d.y() )\n\t\t\t\t.attr( 'dominant-baseline', d => d.dominantBaseline )\n\t\t\t\t.style( 'fill', d => d.color )\n\t\t\t\t.text( d => d.label );\n\n\t\t\tif ( labelStyle ) {\n\t\t\t\tthis.applyMethods( xAxisLabels, 'style', labelStyle );\n\t\t\t}\n\n\t\t\tconst xAxisLabelDims    = Array.from( xAxisLabels._groups[0] ).map( a => a.getBBox() );\n\t\t\tconst xAxisLabelHeights = xAxisLabelDims.map( a => a.height );\n\t\t\t// const xAxisLabelWidths  = xAxisLabelDims.map( a => a.width );\n\t\t\tconst biggestXAxisLabel = Math.max( ...xAxisLabelHeights );\n\n\t\t\tconst dims = ( () => {\n\t\t\t\tif ( axis === 'y-top' ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt : biggestXAxisLabel + spaceBetweenLabelsAndChart,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tb : biggestXAxisLabel + spaceBetweenLabelsAndChart,\n\t\t\t\t};\n\t\t\t} )();\n\n\t\t\tthis.updateDims( dims );\n\t\t\tthis.realignAxisLabels();\n\n\t\t\t// ? center texts as necessary\n\t\t\t// const totalTextSpace = xAxisLabelWidths.reduce( ( sum, w ) => sum + w, 0 );\n\t\t\t// const leftOverSpace  = this.aw - totalTextSpace;\n\t\t\t// const spaceAround    = ( leftOverSpace / ( values.length + 1 ) );\n\n\t\t\treturn xAxisLabelDims;\n\n\t\t},\n\t\tgetX( i ) {\n\t\t\tconst {\n\t\t\t\tl,\n\t\t\t\tbarWidth,\n\t\t\t\tbarSpacing,\n\t\t\t} = this;\n\t\t\tconst x = l + ( barWidth * i ) + ( barSpacing * i ) + ( barSpacing / 2 );\n\t\t\treturn x;\n\t\t},\n\n\t}\n};\n</script>\n\n<style lang='scss'>\n\t.chart{\n\t\t// display: flex;\n\t\t// align-items: stretch;\n\t\t// width: 100%;\n\t\t// height: 300px;\n\t\theight: 100%;\n\t\twidth: 100%;\n\n\t\tsvg {\n\t\t// flex: 2 2 0\n\t\theight: 100%;\n\t\twidth: 70%\n\t\t};\n\t\t.legend{\n\t\t\tdisplay: inline-block;\n\t\t\tvertical-align: top;\n\t\t}\n\t}\n\n</style>\n"]}]}