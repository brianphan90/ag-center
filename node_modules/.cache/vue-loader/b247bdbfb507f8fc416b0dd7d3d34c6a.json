{"remainingRequest":"/Users/brianphan/jets/kf-grower-portal/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/brianphan/jets/kf-grower-portal/src/components/charts/BaseChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/brianphan/jets/kf-grower-portal/src/components/charts/BaseChart.vue","mtime":1617815467467},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/brianphan/jets/kf-grower-portal/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCB7IHY0IGFzIHV1aWQgfSBmcm9tICd1dWlkJzsKaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnOwoKZXhwb3J0IGRlZmF1bHQgewoJcHJvcHMgOiB7CgkJZGF0YSA6IHsKCQkJdHlwZSA6IFtBcnJheSwgT2JqZWN0XSwKCQl9LAoJCWxlZ2VuZCA6IHsKCQkJdHlwZSA6IE9iamVjdCwKCQl9LAoJfSwKCglkYXRhIDogKCkgPT4gKCB7CgkJY2FudmFzIDogbnVsbCwKCQlpZCAgICAgOiB1dWlkKCksCgkJaCAgICAgIDogMCwgLy8gaGVpZ2h0CgkJdyAgICAgIDogMCwgLy8gd2lkdGgKCQlsICAgICAgOiAwLCAvLyBsZWZ0IG9mZnNldAoJCXIgICAgICA6IDAsIC8vIHJpZ2h0IG9mZnNldAoJCXQgICAgICA6IDAsIC8vIHRvcCBvZmZzZXQKCQliICAgICAgOiAwLCAvLyBib3R0b20gb2Zmc2V0Cgl9ICksCgoJY29tcHV0ZWQgOiB7CgkJb3JkZXJlZExlZ2VuZCgpIHsKCQkJY29uc3QgbGVnZW5kID0gT2JqZWN0LmtleXMoIHRoaXMubGVnZW5kICkubWFwKCAoIGtleSApID0+IHsKCQkJCWNvbnN0IHZhbHVlID0gdGhpcy5sZWdlbmRba2V5XTsKCQkJCXJldHVybiB7CgkJCQkJa2V5LAoJCQkJCS4uLnZhbHVlCgkJCQl9OwoJCQl9ICk7CgoJCQlyZXR1cm4gbGVnZW5kLmZpbHRlciggYSA9PiBhLm9yZGVyICE9PSB1bmRlZmluZWQgKS5zb3J0KCAoIGEsIGIgKSA9PiBhLm9yZGVyIC0gYi5vcmRlciApOwoJCX0sCgoJCWFoKCkgeyAvLyBhdmFpbGFibGUgaGVpZ2h0CgkJCWNvbnN0IHsgaCwgdCwgYiB9ID0gdGhpczsKCgkJCXJldHVybiBoIC0gKCB0ICsgYiApOwoJCX0sCgoJCWF3KCkgeyAvLyBhdmFpbGFibGUgd2lkdGgKCQkJY29uc3QgeyB3LCByLCBsIH0gPSB0aGlzOwoKCQkJcmV0dXJuIHcgLSAoIHIgKyBsICk7CgkJfSwKCgl9LAoKCWJlZm9yZURlbGV0ZSgpIHsKCQl3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIHRoaXMucmVzZXQgKTsKCX0sCgoJbWV0aG9kcyA6IHsKCQlpbml0KCBzdmdFbCApIHsKCQkJdGhpcy5yZXNldERpbXMoKTsKCgkJCXRoaXMuY2FudmFzID0gZDMuc2VsZWN0KCBzdmdFbCApOwoJCQl0aGlzLmRyYXcoKTsKCgkJCXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncmVzaXplJywgdGhpcy5yZXNldCwgeyBwYXNzaXZlIDogdHJ1ZSB9ICk7CgkJfSwKCgkJcmVzZXQoKSB7CgkJCXRoaXMuY2FudmFzCgkJCQkuc2VsZWN0QWxsKCAnKicgKQoJCQkJLnJlbW92ZSgpOwoKCQkJdGhpcy5yZXNldERpbXMoKTsKCQkJdGhpcy5kcmF3KCk7CgkJfSwKCgkJcmVzZXREaW1zKCkgewoKCQkJY29uc3QgewoJCQkJY2xpZW50V2lkdGggIDogdywKCQkJCWNsaWVudEhlaWdodCA6IGgsCgkJCX0gPSB0aGlzLiRyZWZzLnN2ZzsKCgkJCXRoaXMuaCA9IGg7CgkJCXRoaXMudyA9IHc7CgkJCXRoaXMudCA9IDA7CgkJCXRoaXMuYiA9IDA7CgkJCXRoaXMubCA9IDA7CgkJCXRoaXMuciA9IDA7CgkJfSwKCgkJdXBkYXRlRGltcyggcHJvcHMgKSB7CgkJCWNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyggcHJvcHMgKTsKCQkJY29uc3QgYWxsb3dlZCA9IHsKCQkJCXQgOiB0cnVlLAoJCQkJYiA6IHRydWUsCgkJCQlsIDogdHJ1ZSwKCQkJCXIgOiB0cnVlLAoJCQkJaCA6IHRydWUsCgkJCQl3IDogdHJ1ZSwKCQkJfTsKCgkJCWtleXMuZm9yRWFjaCggKCBrZXkgKSA9PiB7CgkJCQlpZiAoICFhbGxvd2VkW2tleV0gKSB7CgkJCQkJY29uc29sZS53YXJuaW5nKCBgS2V5ICR7a2V5fSBjYW5ub3QgYmUgdXBkYXRlZCB1c2luZyB1cGRhdGVEaW1zKClgICk7CgoJCQkJCXJldHVybjsKCQkJCX0KCQkJCXRoaXNba2V5XSA9IHByb3BzW2tleV07CgkJCX0gKTsKCQl9LAoKCQlyZWFsaWduQXhpc0xhYmVscygpIHsKCQkJdGhpcy5jYW52YXMuc2VsZWN0QWxsKCAnLmF4aXMtbGFiZWxzJyApCgkJCQkuYXR0ciggJ3gnLCBkID0+IGQueCgpICkKCQkJCS5hdHRyKCAneScsIGQgPT4gZC55KCkgKTsKCgkJCXRoaXMuY2FudmFzLnNlbGVjdEFsbCggJy5heGlzLWluZGljYXRvcnMnICkKCQkJCS5hdHRyKCAnZCcsIGQgPT4gZC5wYXRoKCkgKTsKCQl9LAoKCQlkcmF3QXhpc0luZGljYXRvcnMoIG9wdGlvbnMgKSB7CgkJCWNvbnN0IHlBeGlzID0gL3koLShsZWZ0fHJpZ2h0KSk/LzsKCQkJY29uc3QgeEF4aXMgPSAveCgtKHRvcHxib3R0b20pKT8vOwoKCQkJaWYgKCB5QXhpcy50ZXN0KCBvcHRpb25zLmF4aXMgKSApIHsKCQkJCXJldHVybiB0aGlzLmRyYXdZQXhpc0luZGljYXRvcnMoIG9wdGlvbnMgKTsKCQkJfQoKCQkJaWYgKCB4QXhpcy50ZXN0KCBvcHRpb25zLmF4aXMgKSApIHsKCQkJCXJldHVybiB0aGlzLmRyYXdYQXhpc0luZGljYXRvcnMoIG9wdGlvbnMgKTsKCQkJfQoKCQkJdGhyb3cgbmV3IEVycm9yKCBgIiR7b3B0aW9ucy5heGlzfSIgaXMgbm90IGEgdmFsaWQgYXhpcy4gRXhwZWN0ZWQgb25lIG9mXG5bXG4gICd5JyxcbiAgJ3ktbGVmdCcsXG4gICd5LXJpZ2h0JyxcbiAgJ3gnLFxuICAneC1ib3R0b20nLFxuICAneC10b3AnLFxuXWAgKTsKCQl9LAoKCQlkcmF3WUF4aXNJbmRpY2F0b3JzKCBvcHRpb25zICkgewoJCQljb25zdCB7CgkJCQlheGlzLAoJCQkJcmFuZ2UsCgkJCQlsaW5lcywKCQkJCXBvc3RDaGFyLAoJCQkJY29sb3IsCgkJCQl0cmFuc2Zvcm1MYWJlbCwKCQkJfSA9IG9wdGlvbnM7CgoJCQljb25zdCB7CgkJCQludW1iZXJPZkluZGljYXRvcnMsCgkJCQlzcGFjZUJldHdlZW5MYWJlbHNBbmRMaW5lcywKCQkJfSA9IGxpbmVzOwoKCQkJLyogZHJhdyBpbml0aWFsIGxpbmVzIGFuZCBpbmRpY2F0b3JzICovCgkJCWNvbnN0IHJhbmdlRGlmZmVyZW5jZSA9IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0OwoKCQkJLyogYWRkIHRleHQgbGFiZWxzICovCgoJCQljb25zdCBsYWJlbERhdGEgPSBbXTsKCQkJZm9yICggbGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZJbmRpY2F0b3JzOyBpKysgKSB7CgoJCQkJY29uc3QgZG9taW5hbnRCYXNlbGluZSA9ICggKCkgPT4gewoJCQkJCWlmICggaSA9PT0gbnVtYmVyT2ZJbmRpY2F0b3JzIC0gMSApIHsKCQkJCQkJcmV0dXJuICd0ZXh0LWJlZm9yZS1lZGdlJzsKCQkJCQl9CgoJCQkJCWlmICggaSA9PT0gMCApIHsKCQkJCQkJcmV0dXJuICd0ZXh0LWFmdGVyLWVkZ2UnOwoJCQkJCX0KCgkJCQkJcmV0dXJuICdtaWRkbGUnOwoJCQkJfSApKCk7CgoJCQkJY29uc3QgeSA9ICggKCkgPT4gewoJCQkJCWNvbnN0IGJvdHRvbU9mQ2hhcnQgICAgICA9IHRoaXMudCArIHRoaXMuYWg7CgkJCQkJY29uc3QgZGlzdGFuY2VGcm9tQm90dG9tID0gaSAqICggdGhpcy5haCAvICggbnVtYmVyT2ZJbmRpY2F0b3JzIC0gMSApICk7CgoJCQkJCXJldHVybiBib3R0b21PZkNoYXJ0IC0gZGlzdGFuY2VGcm9tQm90dG9tOwoJCQkJfSApOwoKCQkJCWNvbnN0IHggICAgID0gKCkgPT4gKCAoIGF4aXMgPT09ICd5LXJpZ2h0JyApID8gdGhpcy53IC0gdGhpcy5yIDogdGhpcy5sICk7CgkJCQljb25zdCB4MiAgICA9ICgpID0+ICggKCBheGlzID09PSAneS1yaWdodCcgKSA/IHgoKSAtIHRoaXMuYXcgOiB4KCkgKyB0aGlzLmF3ICk7CgkJCQljb25zdCBwYXRoWCA9ICgpID0+ICggKCBheGlzID09PSAneS1yaWdodCcgKSA/IHgoKSAtIHNwYWNlQmV0d2VlbkxhYmVsc0FuZExpbmVzIDogeCgpICsgc3BhY2VCZXR3ZWVuTGFiZWxzQW5kTGluZXMgKTsKCgkJCQljb25zdCB0ZXh0VmFsdWUgPSBNYXRoLnJvdW5kKCByYW5nZS5zdGFydCArICggKCBpIC8gKCBudW1iZXJPZkluZGljYXRvcnMgLSAxICkgKSAqIHJhbmdlRGlmZmVyZW5jZSApICk7CgkJCQljb25zdCBsYWJlbCAgICAgPSB0cmFuc2Zvcm1MYWJlbCA/IHRyYW5zZm9ybUxhYmVsKCB0ZXh0VmFsdWUgKSA6IHRleHRWYWx1ZTsKCgkJCQljb25zdCB0ZXh0QW5jaG9yID0gKCBheGlzID09PSAneS1yaWdodCcgPyAnc3RhcnQnIDogJ2VuZCcgKTsKCgkJCQlsYWJlbERhdGEucHVzaCggewoJCQkJCXgsCgkJCQkJeDIsCgkJCQkJeSwKCQkJCQl5MiAgIDogeSwKCQkJCQl0ZXh0IDogYCR7bGFiZWx9JHtwb3N0Q2hhciB8fCAnJ31gLAoJCQkJCXBhdGggOiAoKSA9PiBgTSAke3BhdGhYKCl9LCAke3koKX0gTCAke3gyKCl9LCAke3koKX1gLAoJCQkJCWRvbWluYW50QmFzZWxpbmUsCgkJCQkJdGV4dEFuY2hvciwKCQkJCQljb2xvciwKCQkJCX0gKTsKCgkJCX0KCgkJCWNvbnN0IGxpbmVJbmRpY2F0b3JHcm91cHMgPSB0aGlzLmNhbnZhcwoJCQkJLnNlbGVjdEFsbCggYGxpbmUtaW5kaWNhdG9ycy0ke3RoaXMuaWR9YCApCgkJCQkuZGF0YSggbGFiZWxEYXRhICkKCQkJCS5lbnRlcigpCgkJCQkuYXBwZW5kKCAnZycgKSAvLyB3aWxsIGFwcGVuZCBhcyBtYW55IGcncyBhcyB0aGUgbGVuZ3RoIG9mIGxhYmVsRGF0YQoJCQkJLmF0dHIoICdjbGFzcycsIGBsaW5lLWluZGljYXRvcnMtJHt0aGlzLmlkfWAgKTsKCgkJCWlmICggb3B0aW9ucy5sYWJlbHMgIT09IGZhbHNlICkgewoKCQkJCS8qIGRyYXcgbGluZSBsYWJsZXMgKi8KCQkJCWNvbnN0IGxpbmVMYWJlbHMgPSBsaW5lSW5kaWNhdG9yR3JvdXBzLmFwcGVuZCggJ3RleHQnICkKCQkJCQkuYXR0ciggJ2NsYXNzJywgYGxpbmUtaW5kaWNhdG9ycyBsYWJlbC0ke3RoaXMuaWR9IGF4aXMtbGFiZWxzIGR5bmFtaWMtdGV4dC0ke3RoaXMuaWR9YCApCgkJCQkJLmF0dHIoICdkb21pbmFudC1iYXNlbGluZScsIGQgPT4gZC5kb21pbmFudEJhc2VsaW5lICkKCQkJCQkuYXR0ciggJ3gnLCBkID0+IGQueCgpICkKCQkJCQkuYXR0ciggJ3knLCBkID0+IGQueSgpICkKCQkJCQkuc3R5bGUoICdmb250LXNpemUnLCAnMTBweCcgKQoJCQkJCS5zdHlsZSggJ2ZpbGwnLCBjb2xvciApCgkJCQkJLnRleHQoIGQgPT4gZC50ZXh0ICkKCQkJCQkuYXR0ciggJ3RleHQtYW5jaG9yJywgZCA9PiBkLnRleHRBbmNob3IgKTsKCgkJCQkvKiByaWdodCBhbGlnbiB0ZXh0ICovCgoJCQkJY29uc3QgbGluZUxhYmVsV2lkdGhzICA9IEFycmF5LmZyb20oIGxpbmVMYWJlbHMuX2dyb3Vwc1swXSApLm1hcCggYSA9PiBhLmdldEJCb3goKS53aWR0aCApOwoJCQkJY29uc3QgYmlnZ2VzdExpbmVMYWJlbCA9IE1hdGgubWF4KCAuLi5saW5lTGFiZWxXaWR0aHMgKTsKCgkJCQljb25zdCBkaW1zID0gKCAoKSA9PiB7CgkJCQkJY29uc3QgbmV3V2lkdGggPSAoIGJpZ2dlc3RMaW5lTGFiZWwgKyBzcGFjZUJldHdlZW5MYWJlbHNBbmRMaW5lcyApOwoKCQkJCQlpZiAoIGF4aXMgPT09ICd5LXJpZ2h0JyApIHsKCQkJCQkJcmV0dXJuIHsKCQkJCQkJCXIgOiBuZXdXaWR0aCwKCQkJCQkJfTsKCQkJCQl9CgoJCQkJCXJldHVybiB7CgkJCQkJCWwgOiBuZXdXaWR0aCwKCQkJCQl9OwoJCQkJfSApKCk7CgoJCQkJdGhpcy51cGRhdGVEaW1zKCBkaW1zICk7CgkJCQl0aGlzLnJlYWxpZ25BeGlzTGFiZWxzKCk7CgoJCQl9CgoJCQkvKiBkcmF3IGxpbmVzICovCgkJCWxpbmVJbmRpY2F0b3JHcm91cHMuYXBwZW5kKCAncGF0aCcgKQoJCQkJLmF0dHIoICdkJywgZCA9PiBkLnBhdGgoKSApCgkJCQkuYXR0ciggJ2NsYXNzJywgYGR5bmFtaWMtc3Ryb2tlLSR7dGhpcy5pZH0gYXhpcy1pbmRpY2F0b3JzYCApCgkJCQkuc3R5bGUoICdzdHJva2UtZGFzaGFycmF5JywgJzIsIDQnICkKCQkJCS5zdHlsZSggJ3N0cm9rZScsIGNvbG9yICk7CgoJCQlyZXR1cm4gbGluZUluZGljYXRvckdyb3VwczsKCgkJfSwKCgkJZHJhd1hBeGlzSW5kaWNhdG9ycyggb3B0aW9ucyApIHsKCQkJY29uc3QgewoJCQkJYXhpcywKCQkJCXZhbHVlcywKCQkJCXNwYWNlQmV0d2VlbkxhYmVsc0FuZENoYXJ0LAoJCQkJbGFiZWxTdHlsZSwKCQkJfSA9IG9wdGlvbnM7CgkJCWNvbnNvbGUubG9nKCB2YWx1ZXMgKTsKCQkJY29uc3QgZ2V0WCA9ICggaSApID0+IHsKCQkJCWNvbnN0IHsgYXcsIGwgfSA9IHRoaXM7CgkJCQljb25zdCByZXQgPSBsICsgKCAoIGF3IC8gKCB2YWx1ZXMubGVuZ3RoICsgMSApICkgKiAoIGkgKyAxICkgKTsKCQkJCWNvbnNvbGUubG9nKCByZXQgKTsKCQkJCXJldHVybiByZXQ7CgkJCX07CgoJCQljb25zdCB4QXhpc0RhdGEgPSB2YWx1ZXMubWFwKCAoIGRhdHVtLCBpICkgPT4gewoJCQkJY29uc3QgeSA9ICgpID0+ICggKCBheGlzID09PSAneC10b3AnICkgPyB0aGlzLnQgOiB0aGlzLnQgKyB0aGlzLmFoICk7CgkJCQljb25zdCB4ID0gKCkgPT4gZ2V0WCggaSApOwoKCQkJCXJldHVybiB7CgkJCQkJLi4uZGF0dW0sCgkJCQkJeCwKCQkJCQl5LAoJCQkJCXRleHRBbmNob3IgICAgICAgOiAnbWlkZGxlJywKCQkJCQlkb21pbmFudEJhc2VsaW5lIDogKCBheGlzID09PSAneC10b3AnICkgPyAndGV4dC1iZWZvcmUtZWRnZScgOiAndGV4dC1hZnRlci1lZGdlJywKCQkJCX07CgkJCX0gKTsKCgkJCWNvbnN0IHhBeGlzTGFiZWxzID0gdGhpcy5jYW52YXMKCQkJCS5zZWxlY3RBbGwoICd4LWF4aXMtbGFiZWxzIGF4aXMtbGFiZWwnICkKCQkJCS5kYXRhKCB4QXhpc0RhdGEgKQoJCQkJLmVudGVyKCkKCQkJCS5hcHBlbmQoICd0ZXh0JyApCgkJCQkuYXR0ciggJ3RleHQtYW5jaG9yJywgZCA9PiBkLnRleHRBbmNob3IgKQoJCQkJLmF0dHIoICd4JywgZCA9PiBkLngoKSApCgkJCQkuYXR0ciggJ3knLCBkID0+IGQueSgpICkKCQkJCS5hdHRyKCAnZG9taW5hbnQtYmFzZWxpbmUnLCBkID0+IGQuZG9taW5hbnRCYXNlbGluZSApCgkJCQkuc3R5bGUoICdmaWxsJywgZCA9PiBkLmNvbG9yICkKCQkJCS50ZXh0KCBkID0+IGQubGFiZWwgKTsKCgkJCWlmICggbGFiZWxTdHlsZSApIHsKCQkJCXRoaXMuYXBwbHlNZXRob2RzKCB4QXhpc0xhYmVscywgJ3N0eWxlJywgbGFiZWxTdHlsZSApOwoJCQl9CgoJCQljb25zdCB4QXhpc0xhYmVsRGltcyAgICA9IEFycmF5LmZyb20oIHhBeGlzTGFiZWxzLl9ncm91cHNbMF0gKS5tYXAoIGEgPT4gYS5nZXRCQm94KCkgKTsKCQkJY29uc3QgeEF4aXNMYWJlbEhlaWdodHMgPSB4QXhpc0xhYmVsRGltcy5tYXAoIGEgPT4gYS5oZWlnaHQgKTsKCQkJLy8gY29uc3QgeEF4aXNMYWJlbFdpZHRocyAgPSB4QXhpc0xhYmVsRGltcy5tYXAoIGEgPT4gYS53aWR0aCApOwoJCQljb25zdCBiaWdnZXN0WEF4aXNMYWJlbCA9IE1hdGgubWF4KCAuLi54QXhpc0xhYmVsSGVpZ2h0cyApOwoKCQkJY29uc3QgZGltcyA9ICggKCkgPT4gewoJCQkJaWYgKCBheGlzID09PSAneS10b3AnICkgewoJCQkJCXJldHVybiB7CgkJCQkJCXQgOiBiaWdnZXN0WEF4aXNMYWJlbCArIHNwYWNlQmV0d2VlbkxhYmVsc0FuZENoYXJ0LAoJCQkJCX07CgkJCQl9CgoJCQkJcmV0dXJuIHsKCQkJCQliIDogYmlnZ2VzdFhBeGlzTGFiZWwgKyBzcGFjZUJldHdlZW5MYWJlbHNBbmRDaGFydCwKCQkJCX07CgkJCX0gKSgpOwoKCQkJdGhpcy51cGRhdGVEaW1zKCBkaW1zICk7CgkJCXRoaXMucmVhbGlnbkF4aXNMYWJlbHMoKTsKCQkJcmV0dXJuIHhBeGlzRGF0YTsKCgkJfSwKCgkJYXBwbHlNZXRob2RzKCBub2RlcywgbWV0aG9kLCBvcHRpb25zID0gW10gKSB7CgkJCW9wdGlvbnMucmVkdWNlKCAoIGQzaXRlbSwgb3B0aW9uICkgPT4gewoJCQkJY29uc3QgW3Byb3AsIHZhbHVlXSA9IG9wdGlvbjsKCgkJCQlyZXR1cm4gZDNpdGVtW21ldGhvZF0oIHByb3AsICggZCApID0+IHsKCQkJCQlpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHsKCQkJCQkJcmV0dXJuIHZhbHVlKCBkICk7CgkJCQkJfQoKCQkJCQlyZXR1cm4gdmFsdWU7CgkJCQl9ICk7CgkJCX0sIG5vZGVzICk7CgkJfSwKCgkJZ2V0RGF0YVJhbmdlKCB5VmFsdWVzLCBzY2FsZWQgKSB7CgkJCWNvbnN0IGJpZ2dlc3QgICAgPSBNYXRoLm1heCggLi4ueVZhbHVlcyApOwoJCQljb25zdCBzbWFsbGVzdCAgID0gTWF0aC5taW4oIC4uLnlWYWx1ZXMgKTsKCQkJY29uc3QgZGlmZmVyZW5jZSA9ICggYmlnZ2VzdCAtIHNtYWxsZXN0ICk7CgkJCWlmICggZGlmZmVyZW5jZSA9PT0gMCApIHsKCgkJCQlsZXQgcG93ZXIgPSAwOwoKCQkJCXdoaWxlICggYmlnZ2VzdCAvICggMTAgKiogcG93ZXIgKSA+IDEwICkgewoJCQkJCXBvd2VyICs9IDE7CgkJCQl9CgoJCQkJY29uc3QgaW5jcmVtZW50ID0gMTAgKiogcG93ZXI7CgoJCQkJcmV0dXJuIHsKCQkJCQlzdGFydCA6IHNjYWxlZCA/IE1hdGguZmxvb3IoIGJpZ2dlc3QgLyBpbmNyZW1lbnQgKSAqIGluY3JlbWVudCA6IDAsCgkJCQkJZW5kICAgOiBNYXRoLmNlaWwoIGJpZ2dlc3QgLyBpbmNyZW1lbnQgKSAqIGluY3JlbWVudCwKCQkJCX07CgoJCQl9CgoJCQkvLyBmYWN0b3Igb2YgdGVuIHRvIG11bHRpcGx5CgkJCS8vIGZvciB0aGUgbGFiZWwncyBzY2FsZQoJCQljb25zdCBzY2FsZSA9ICggKCkgPT4gewoKCQkJCWxldCBwb3dlciA9IDA7CgoJCQkJd2hpbGUgKCBkaWZmZXJlbmNlIC8gKCAxMCAqKiBwb3dlciApID4gMTAgKSB7CgkJCQkJcG93ZXIgKz0gMTsKCQkJCX0KCgkJCQlyZXR1cm4gcG93ZXI7CgoJCQl9ICkoKTsKCQkJY29uc3QgcmVsZXZhbnRJbmNyZW1lbnQgPSAgMTAgKiogc2NhbGU7CgoJCQkvLyB3ZSdsbCBzdGFydCBieSB0cnlpbmcgdG8gZG8gYQoJCQkvLyBzY2FsZSBmcm9tIHRoZSBjbG9zZXN0IGluc3RhbmNlIG9mCgkJCS8vIG91ciByZWxldmFudCBpbmNyZW1lbnQgdG8gYSBwb2ludAoJCQkvLyBmb3VyIG1vcmUgcmVsZXZhbnRJbmNyZW1lbnRzIGF3YXkKCQkJY29uc3Qgc3RhcnQgPSAhc2NhbGVkID8gMCA6ICggTWF0aC5mbG9vciggc21hbGxlc3QgLyByZWxldmFudEluY3JlbWVudCApICogcmVsZXZhbnRJbmNyZW1lbnQgKTsKCQkJY29uc3QgcmFuZ2UgPSAoIE1hdGguY2VpbCggKCBkaWZmZXJlbmNlICsgc21hbGxlc3QgLSBzdGFydCApIC8gcmVsZXZhbnRJbmNyZW1lbnQgKSApICogcmVsZXZhbnRJbmNyZW1lbnQ7CgkJCWNvbnN0IGVuZCAgID0gc3RhcnQgKyByYW5nZTsKCgkJCXJldHVybiB7CgkJCQlzdGFydCwKCQkJCWVuZCwKCQkJfTsKCQl9LAoKCQlnZXRZVmFsdWUoIHZhbHVlLCByYW5nZSApIHsKCQkJY29uc3QgeyB0LCBhaCB9ID0gdGhpczsKCQkJY29uc3QgeyBlbmQsIHN0YXJ0IH0gPSByYW5nZTsKCgkJCWNvbnN0IGZyYWN0aW9uID0gKCB2YWx1ZSAtIHN0YXJ0ICkgLyAoIGVuZCAtIHN0YXJ0ICk7CgoJCQlyZXR1cm4gdCArICggYWggLSAoIGZyYWN0aW9uICogYWggKSApOwoJCX0sCgoJCWdldExpbmVhckZ1bmN0aW9uRnJvbVR3b1BvaW50cyggcG9pbnRPbmUsIHBvaW50VHdvICkgewoJCQlyZXR1cm4gKCB4ICkgPT4gewoJCQkJLy8gcmlzZSBvdmVyIHJ1bi4gaW1wb3J0YW50CgkJCQljb25zdCBzbG9wZSA9ICggcG9pbnRPbmUueSgpIC0gcG9pbnRUd28ueSgpICkgLyAoIHBvaW50T25lLngoKSAtIHBvaW50VHdvLngoKSApOwoKCQkJCS8vIGIgPSB5IC0gbSh4KTsKCQkJCWNvbnN0IGIgPSBwb2ludE9uZS55KCkgLSAoIHNsb3BlICogcG9pbnRPbmUueCgpICk7CgoJCQkJLy8geSA9IG0oeCkgKyBiOwoJCQkJcmV0dXJuICggc2xvcGUgKiB4ICkgKyBiOwoJCQl9OwoJCX0sCgoJCXdyYXBUZXh0KCB0ZXh0LCB3aWR0aCApIHsKCgkJCWNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbSggdGV4dC5fZ3JvdXBzWzBdICk7CgoJCQlub2Rlcy5mb3JFYWNoKCAoIG5vZGUgKSA9PiB7CgkJCQljb25zdCB0ZXh0Tm9kZSAgID0gZDMuc2VsZWN0KCBub2RlICk7CgkJCQljb25zdCB0b3RhbFdvcmRzID0gdGV4dE5vZGUKCQkJCQkudGV4dCgpCgkJCQkJLnNwbGl0KCAvXHMrLyApCgkJCQkJLnJldmVyc2UoKTsKCgkJCQljb25zdCBsaW5lSGVpZ2h0ID0gMS4xOyAvLyBlbXMKCQkJCWNvbnN0IHkgICAgICAgICAgPSB0ZXh0Tm9kZS5hdHRyKCAneScgKTsKCQkJCWNvbnN0IHggICAgICAgICAgPSB0ZXh0Tm9kZS5hdHRyKCAneCcgKTsKCQkJCWNvbnN0IGR5ICAgICAgICAgPSBwYXJzZUZsb2F0KCB0ZXh0Tm9kZS5hdHRyKCAnZHknICkgKSB8fCAwOwoKCQkJCWxldCB0c3BhbiA9IHRleHROb2RlCgkJCQkJLnRleHQoIG51bGwgKQoJCQkJCS5hcHBlbmQoICd0c3BhbicgKQoJCQkJCS5hdHRyKCAneCcsIHggKQoJCQkJCS5hdHRyKCAneScsIHkgKQoJCQkJCS5hdHRyKCAnZHknLCBgJHtkeX1lbWAgKTsKCgkJCQlsZXQgbGluZSAgICAgICA9IFtdOwoJCQkJbGV0IGxpbmVOdW1iZXIgPSAwOwoJCQkJd2hpbGUgKCB0b3RhbFdvcmRzLmxlbmd0aCApIHsKCQkJCQljb25zdCB3b3JkID0gdG90YWxXb3Jkcy5wb3AoKTsKCgkJCQkJLy8gYWRkIHRoaXMgd29yZCB0byB0aGUgbGluZQoJCQkJCWxpbmUucHVzaCggd29yZCApOwoKCQkJCQkvLyBzZXQgdGhlIHRzcGFuJ3MgY29udGVudCB0bwoJCQkJCS8vIHRoZSB2YWx1ZSBvZiBvdXIgbGluZQoJCQkJCXRzcGFuLnRleHQoIGxpbmUuam9pbiggJyAnICkgKTsKCgkJCQkJLy8gZGV0ZXJtaW5lIGlmIHRoZSBsaW5lIGlzIG5vdwoJCQkJCS8vIG92ZXJmbG93aW5nCgkJCQkJY29uc3QgdGV4dExlbmd0aCA9IHRzcGFuCgkJCQkJCS5ub2RlKCkKCQkJCQkJLmdldENvbXB1dGVkVGV4dExlbmd0aCgpOwoKCQkJCQljb25zdCBvdmVyZmxvd2luZyA9IHRleHRMZW5ndGggPiB3aWR0aDsKCgkJCQkJaWYgKCBvdmVyZmxvd2luZyApIHsKCQkJCQkJLy8gcmVtb3ZlIHRoYXQgd29yZCwgYXMgaXQgd2FzCgkJCQkJCS8vIHRvbyBsb25nCgkJCQkJCWxpbmUucG9wKCk7CgoJCQkJCQkvLyByZXNldCB0aGUgdGV4dCB0byB0aGUgbGluZSB3aXRob3V0CgkJCQkJCS8vIHRoZSB3b3JkIHRoYXQgb3ZlcmZsb3dlZAoJCQkJCQl0c3Bhbi50ZXh0KCBsaW5lLmpvaW4oICcgJyApICk7CgoJCQkJCQkvLyBwdXQgdGhpcyB3b3JkIGluIHRoZSBuZXh0IGxpbmUKCQkJCQkJbGluZSA9IFt3b3JkXTsKCgkJCQkJCS8vIGFkZCBhIG5ldyB0c2FwbgoJCQkJCQl0c3BhbiA9IHRleHROb2RlCgkJCQkJCQkuYXBwZW5kKCAndHNwYW4nICkKCQkJCQkJCS5hdHRyKCAneCcsIHggKQoJCQkJCQkJLmF0dHIoICd5JywgeSApCgkJCQkJCQkuYXR0ciggJ2R5JywgYCR7KCArK2xpbmVOdW1iZXIgKiBsaW5lSGVpZ2h0ICkgKyBkeX1lbWAgKQoJCQkJCQkJLnRleHQoIHdvcmQgKTsKCQkJCQl9CgkJCQl9CgoJCQkJdGV4dE5vZGUuc2VsZWN0QWxsKCAndHNwYW4nICkKCQkJCQkuYXR0ciggJ2R5JywgKCBkLCBpLCB0c3BhbnMgKSA9PiB7CgoJCQkJCQljb25zdCBudW1iZXJPZkxpbmVzID0gQXJyYXkuZnJvbSggdHNwYW5zICkKCQkJCQkJCS5maWx0ZXIoIGEgPT4gYS5pbm5lckhUTUwgIT09ICcnICkKCQkJCQkJCS5sZW5ndGggLSAxOwoKCQkJCQkJY29uc3QgdHNwYW5Ob2RlICA9IHRzcGFuc1tpXTsKCQkJCQkJY29uc3Qgc3RhcnRpbmdEeSA9IHBhcnNlRmxvYXQoIGQzLnNlbGVjdCggdHNwYW5Ob2RlICkuYXR0ciggJ2R5JyApLCAxMCApOwoKCQkJCQkJY29uc3QgaGFsZlRvdGFsVGV4dEhlaWdodCA9ICggKCBudW1iZXJPZkxpbmVzIC8gMiApICogbGluZUhlaWdodCApOwoJCQkJCQljb25zdCBsaW5lUG9zaXRpb24gICAgICAgID0gKCBsaW5lSGVpZ2h0ICogbGluZU51bWJlciApOwoKCQkJCQkJLy8gY2VudGVycyB0aGUgd3JhcHBlciB0ZXh0CgkJCQkJCXJldHVybiBgJHsoIHN0YXJ0aW5nRHkgfHwgMCApIC0gbGluZVBvc2l0aW9uICsgaGFsZlRvdGFsVGV4dEhlaWdodH1lbWA7CgoJCQkJCX0gKTsKCQkJfSApOwoJCX0sCgoJCXBhdGhGcm9tUG9pbnRzKCBwb2ludHMsIGNsb3NlZCA9IHRydWUgKSB7CgoJCQljb25zdCBlbmRDaGFyYWN0ZXIgPSBjbG9zZWQgPyAnIFonIDogJyc7CgkJCWNvbnN0IHBhdGggICAgICAgICA9IHBvaW50cy5yZWR1Y2UoICggYSwgYiwgaSApID0+IHsKCgkJCQlpZiAoIHR5cGVvZiBhICE9PSAnb2JqZWN0JyApIHsKCQkJCQlyZXR1cm4gYCR7YX0gTCAke2IueH0gJHtiLnl9JHtpID09PSAoIHBvaW50cy5sZW5ndGggLSAxICkgPyBlbmRDaGFyYWN0ZXIgOiAnJ31gOwoJCQkJfQoKCQkJCXJldHVybiBgTSAke2IueH0gJHtiLnl9YDsKCgkJCX0sIHt9ICk7CgoJCQlyZXR1cm4gcGF0aDsKCgkJfSwKCX0sCn07Cg=="},{"version":3,"sources":["BaseChart.vue"],"names":[],"mappings":";AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA","file":"BaseChart.vue","sourceRoot":"src/components/charts","sourcesContent":["<script>\nimport { v4 as uuid } from 'uuid';\nimport * as d3 from 'd3';\n\nexport default {\n\tprops : {\n\t\tdata : {\n\t\t\ttype : [Array, Object],\n\t\t},\n\t\tlegend : {\n\t\t\ttype : Object,\n\t\t},\n\t},\n\n\tdata : () => ( {\n\t\tcanvas : null,\n\t\tid     : uuid(),\n\t\th      : 0, // height\n\t\tw      : 0, // width\n\t\tl      : 0, // left offset\n\t\tr      : 0, // right offset\n\t\tt      : 0, // top offset\n\t\tb      : 0, // bottom offset\n\t} ),\n\n\tcomputed : {\n\t\torderedLegend() {\n\t\t\tconst legend = Object.keys( this.legend ).map( ( key ) => {\n\t\t\t\tconst value = this.legend[key];\n\t\t\t\treturn {\n\t\t\t\t\tkey,\n\t\t\t\t\t...value\n\t\t\t\t};\n\t\t\t} );\n\n\t\t\treturn legend.filter( a => a.order !== undefined ).sort( ( a, b ) => a.order - b.order );\n\t\t},\n\n\t\tah() { // available height\n\t\t\tconst { h, t, b } = this;\n\n\t\t\treturn h - ( t + b );\n\t\t},\n\n\t\taw() { // available width\n\t\t\tconst { w, r, l } = this;\n\n\t\t\treturn w - ( r + l );\n\t\t},\n\n\t},\n\n\tbeforeDelete() {\n\t\twindow.removeEventListener( 'resize', this.reset );\n\t},\n\n\tmethods : {\n\t\tinit( svgEl ) {\n\t\t\tthis.resetDims();\n\n\t\t\tthis.canvas = d3.select( svgEl );\n\t\t\tthis.draw();\n\n\t\t\twindow.addEventListener( 'resize', this.reset, { passive : true } );\n\t\t},\n\n\t\treset() {\n\t\t\tthis.canvas\n\t\t\t\t.selectAll( '*' )\n\t\t\t\t.remove();\n\n\t\t\tthis.resetDims();\n\t\t\tthis.draw();\n\t\t},\n\n\t\tresetDims() {\n\n\t\t\tconst {\n\t\t\t\tclientWidth  : w,\n\t\t\t\tclientHeight : h,\n\t\t\t} = this.$refs.svg;\n\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tthis.t = 0;\n\t\t\tthis.b = 0;\n\t\t\tthis.l = 0;\n\t\t\tthis.r = 0;\n\t\t},\n\n\t\tupdateDims( props ) {\n\t\t\tconst keys = Object.keys( props );\n\t\t\tconst allowed = {\n\t\t\t\tt : true,\n\t\t\t\tb : true,\n\t\t\t\tl : true,\n\t\t\t\tr : true,\n\t\t\t\th : true,\n\t\t\t\tw : true,\n\t\t\t};\n\n\t\t\tkeys.forEach( ( key ) => {\n\t\t\t\tif ( !allowed[key] ) {\n\t\t\t\t\tconsole.warning( `Key ${key} cannot be updated using updateDims()` );\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis[key] = props[key];\n\t\t\t} );\n\t\t},\n\n\t\trealignAxisLabels() {\n\t\t\tthis.canvas.selectAll( '.axis-labels' )\n\t\t\t\t.attr( 'x', d => d.x() )\n\t\t\t\t.attr( 'y', d => d.y() );\n\n\t\t\tthis.canvas.selectAll( '.axis-indicators' )\n\t\t\t\t.attr( 'd', d => d.path() );\n\t\t},\n\n\t\tdrawAxisIndicators( options ) {\n\t\t\tconst yAxis = /y(-(left|right))?/;\n\t\t\tconst xAxis = /x(-(top|bottom))?/;\n\n\t\t\tif ( yAxis.test( options.axis ) ) {\n\t\t\t\treturn this.drawYAxisIndicators( options );\n\t\t\t}\n\n\t\t\tif ( xAxis.test( options.axis ) ) {\n\t\t\t\treturn this.drawXAxisIndicators( options );\n\t\t\t}\n\n\t\t\tthrow new Error( `\"${options.axis}\" is not a valid axis. Expected one of\\n[\\n  'y',\\n  'y-left',\\n  'y-right',\\n  'x',\\n  'x-bottom',\\n  'x-top',\\n]` );\n\t\t},\n\n\t\tdrawYAxisIndicators( options ) {\n\t\t\tconst {\n\t\t\t\taxis,\n\t\t\t\trange,\n\t\t\t\tlines,\n\t\t\t\tpostChar,\n\t\t\t\tcolor,\n\t\t\t\ttransformLabel,\n\t\t\t} = options;\n\n\t\t\tconst {\n\t\t\t\tnumberOfIndicators,\n\t\t\t\tspaceBetweenLabelsAndLines,\n\t\t\t} = lines;\n\n\t\t\t/* draw initial lines and indicators */\n\t\t\tconst rangeDifference = range.end - range.start;\n\n\t\t\t/* add text labels */\n\n\t\t\tconst labelData = [];\n\t\t\tfor ( let i = 0; i < numberOfIndicators; i++ ) {\n\n\t\t\t\tconst dominantBaseline = ( () => {\n\t\t\t\t\tif ( i === numberOfIndicators - 1 ) {\n\t\t\t\t\t\treturn 'text-before-edge';\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( i === 0 ) {\n\t\t\t\t\t\treturn 'text-after-edge';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 'middle';\n\t\t\t\t} )();\n\n\t\t\t\tconst y = ( () => {\n\t\t\t\t\tconst bottomOfChart      = this.t + this.ah;\n\t\t\t\t\tconst distanceFromBottom = i * ( this.ah / ( numberOfIndicators - 1 ) );\n\n\t\t\t\t\treturn bottomOfChart - distanceFromBottom;\n\t\t\t\t} );\n\n\t\t\t\tconst x     = () => ( ( axis === 'y-right' ) ? this.w - this.r : this.l );\n\t\t\t\tconst x2    = () => ( ( axis === 'y-right' ) ? x() - this.aw : x() + this.aw );\n\t\t\t\tconst pathX = () => ( ( axis === 'y-right' ) ? x() - spaceBetweenLabelsAndLines : x() + spaceBetweenLabelsAndLines );\n\n\t\t\t\tconst textValue = Math.round( range.start + ( ( i / ( numberOfIndicators - 1 ) ) * rangeDifference ) );\n\t\t\t\tconst label     = transformLabel ? transformLabel( textValue ) : textValue;\n\n\t\t\t\tconst textAnchor = ( axis === 'y-right' ? 'start' : 'end' );\n\n\t\t\t\tlabelData.push( {\n\t\t\t\t\tx,\n\t\t\t\t\tx2,\n\t\t\t\t\ty,\n\t\t\t\t\ty2   : y,\n\t\t\t\t\ttext : `${label}${postChar || ''}`,\n\t\t\t\t\tpath : () => `M ${pathX()}, ${y()} L ${x2()}, ${y()}`,\n\t\t\t\t\tdominantBaseline,\n\t\t\t\t\ttextAnchor,\n\t\t\t\t\tcolor,\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst lineIndicatorGroups = this.canvas\n\t\t\t\t.selectAll( `line-indicators-${this.id}` )\n\t\t\t\t.data( labelData )\n\t\t\t\t.enter()\n\t\t\t\t.append( 'g' ) // will append as many g's as the length of labelData\n\t\t\t\t.attr( 'class', `line-indicators-${this.id}` );\n\n\t\t\tif ( options.labels !== false ) {\n\n\t\t\t\t/* draw line lables */\n\t\t\t\tconst lineLabels = lineIndicatorGroups.append( 'text' )\n\t\t\t\t\t.attr( 'class', `line-indicators label-${this.id} axis-labels dynamic-text-${this.id}` )\n\t\t\t\t\t.attr( 'dominant-baseline', d => d.dominantBaseline )\n\t\t\t\t\t.attr( 'x', d => d.x() )\n\t\t\t\t\t.attr( 'y', d => d.y() )\n\t\t\t\t\t.style( 'font-size', '10px' )\n\t\t\t\t\t.style( 'fill', color )\n\t\t\t\t\t.text( d => d.text )\n\t\t\t\t\t.attr( 'text-anchor', d => d.textAnchor );\n\n\t\t\t\t/* right align text */\n\n\t\t\t\tconst lineLabelWidths  = Array.from( lineLabels._groups[0] ).map( a => a.getBBox().width );\n\t\t\t\tconst biggestLineLabel = Math.max( ...lineLabelWidths );\n\n\t\t\t\tconst dims = ( () => {\n\t\t\t\t\tconst newWidth = ( biggestLineLabel + spaceBetweenLabelsAndLines );\n\n\t\t\t\t\tif ( axis === 'y-right' ) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tr : newWidth,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tl : newWidth,\n\t\t\t\t\t};\n\t\t\t\t} )();\n\n\t\t\t\tthis.updateDims( dims );\n\t\t\t\tthis.realignAxisLabels();\n\n\t\t\t}\n\n\t\t\t/* draw lines */\n\t\t\tlineIndicatorGroups.append( 'path' )\n\t\t\t\t.attr( 'd', d => d.path() )\n\t\t\t\t.attr( 'class', `dynamic-stroke-${this.id} axis-indicators` )\n\t\t\t\t.style( 'stroke-dasharray', '2, 4' )\n\t\t\t\t.style( 'stroke', color );\n\n\t\t\treturn lineIndicatorGroups;\n\n\t\t},\n\n\t\tdrawXAxisIndicators( options ) {\n\t\t\tconst {\n\t\t\t\taxis,\n\t\t\t\tvalues,\n\t\t\t\tspaceBetweenLabelsAndChart,\n\t\t\t\tlabelStyle,\n\t\t\t} = options;\n\t\t\tconsole.log( values );\n\t\t\tconst getX = ( i ) => {\n\t\t\t\tconst { aw, l } = this;\n\t\t\t\tconst ret = l + ( ( aw / ( values.length + 1 ) ) * ( i + 1 ) );\n\t\t\t\tconsole.log( ret );\n\t\t\t\treturn ret;\n\t\t\t};\n\n\t\t\tconst xAxisData = values.map( ( datum, i ) => {\n\t\t\t\tconst y = () => ( ( axis === 'x-top' ) ? this.t : this.t + this.ah );\n\t\t\t\tconst x = () => getX( i );\n\n\t\t\t\treturn {\n\t\t\t\t\t...datum,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\ttextAnchor       : 'middle',\n\t\t\t\t\tdominantBaseline : ( axis === 'x-top' ) ? 'text-before-edge' : 'text-after-edge',\n\t\t\t\t};\n\t\t\t} );\n\n\t\t\tconst xAxisLabels = this.canvas\n\t\t\t\t.selectAll( 'x-axis-labels axis-label' )\n\t\t\t\t.data( xAxisData )\n\t\t\t\t.enter()\n\t\t\t\t.append( 'text' )\n\t\t\t\t.attr( 'text-anchor', d => d.textAnchor )\n\t\t\t\t.attr( 'x', d => d.x() )\n\t\t\t\t.attr( 'y', d => d.y() )\n\t\t\t\t.attr( 'dominant-baseline', d => d.dominantBaseline )\n\t\t\t\t.style( 'fill', d => d.color )\n\t\t\t\t.text( d => d.label );\n\n\t\t\tif ( labelStyle ) {\n\t\t\t\tthis.applyMethods( xAxisLabels, 'style', labelStyle );\n\t\t\t}\n\n\t\t\tconst xAxisLabelDims    = Array.from( xAxisLabels._groups[0] ).map( a => a.getBBox() );\n\t\t\tconst xAxisLabelHeights = xAxisLabelDims.map( a => a.height );\n\t\t\t// const xAxisLabelWidths  = xAxisLabelDims.map( a => a.width );\n\t\t\tconst biggestXAxisLabel = Math.max( ...xAxisLabelHeights );\n\n\t\t\tconst dims = ( () => {\n\t\t\t\tif ( axis === 'y-top' ) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tt : biggestXAxisLabel + spaceBetweenLabelsAndChart,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tb : biggestXAxisLabel + spaceBetweenLabelsAndChart,\n\t\t\t\t};\n\t\t\t} )();\n\n\t\t\tthis.updateDims( dims );\n\t\t\tthis.realignAxisLabels();\n\t\t\treturn xAxisData;\n\n\t\t},\n\n\t\tapplyMethods( nodes, method, options = [] ) {\n\t\t\toptions.reduce( ( d3item, option ) => {\n\t\t\t\tconst [prop, value] = option;\n\n\t\t\t\treturn d3item[method]( prop, ( d ) => {\n\t\t\t\t\tif ( typeof value === 'function' ) {\n\t\t\t\t\t\treturn value( d );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value;\n\t\t\t\t} );\n\t\t\t}, nodes );\n\t\t},\n\n\t\tgetDataRange( yValues, scaled ) {\n\t\t\tconst biggest    = Math.max( ...yValues );\n\t\t\tconst smallest   = Math.min( ...yValues );\n\t\t\tconst difference = ( biggest - smallest );\n\t\t\tif ( difference === 0 ) {\n\n\t\t\t\tlet power = 0;\n\n\t\t\t\twhile ( biggest / ( 10 ** power ) > 10 ) {\n\t\t\t\t\tpower += 1;\n\t\t\t\t}\n\n\t\t\t\tconst increment = 10 ** power;\n\n\t\t\t\treturn {\n\t\t\t\t\tstart : scaled ? Math.floor( biggest / increment ) * increment : 0,\n\t\t\t\t\tend   : Math.ceil( biggest / increment ) * increment,\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// factor of ten to multiply\n\t\t\t// for the label's scale\n\t\t\tconst scale = ( () => {\n\n\t\t\t\tlet power = 0;\n\n\t\t\t\twhile ( difference / ( 10 ** power ) > 10 ) {\n\t\t\t\t\tpower += 1;\n\t\t\t\t}\n\n\t\t\t\treturn power;\n\n\t\t\t} )();\n\t\t\tconst relevantIncrement =  10 ** scale;\n\n\t\t\t// we'll start by trying to do a\n\t\t\t// scale from the closest instance of\n\t\t\t// our relevant increment to a point\n\t\t\t// four more relevantIncrements away\n\t\t\tconst start = !scaled ? 0 : ( Math.floor( smallest / relevantIncrement ) * relevantIncrement );\n\t\t\tconst range = ( Math.ceil( ( difference + smallest - start ) / relevantIncrement ) ) * relevantIncrement;\n\t\t\tconst end   = start + range;\n\n\t\t\treturn {\n\t\t\t\tstart,\n\t\t\t\tend,\n\t\t\t};\n\t\t},\n\n\t\tgetYValue( value, range ) {\n\t\t\tconst { t, ah } = this;\n\t\t\tconst { end, start } = range;\n\n\t\t\tconst fraction = ( value - start ) / ( end - start );\n\n\t\t\treturn t + ( ah - ( fraction * ah ) );\n\t\t},\n\n\t\tgetLinearFunctionFromTwoPoints( pointOne, pointTwo ) {\n\t\t\treturn ( x ) => {\n\t\t\t\t// rise over run. important\n\t\t\t\tconst slope = ( pointOne.y() - pointTwo.y() ) / ( pointOne.x() - pointTwo.x() );\n\n\t\t\t\t// b = y - m(x);\n\t\t\t\tconst b = pointOne.y() - ( slope * pointOne.x() );\n\n\t\t\t\t// y = m(x) + b;\n\t\t\t\treturn ( slope * x ) + b;\n\t\t\t};\n\t\t},\n\n\t\twrapText( text, width ) {\n\n\t\t\tconst nodes = Array.from( text._groups[0] );\n\n\t\t\tnodes.forEach( ( node ) => {\n\t\t\t\tconst textNode   = d3.select( node );\n\t\t\t\tconst totalWords = textNode\n\t\t\t\t\t.text()\n\t\t\t\t\t.split( /\\s+/ )\n\t\t\t\t\t.reverse();\n\n\t\t\t\tconst lineHeight = 1.1; // ems\n\t\t\t\tconst y          = textNode.attr( 'y' );\n\t\t\t\tconst x          = textNode.attr( 'x' );\n\t\t\t\tconst dy         = parseFloat( textNode.attr( 'dy' ) ) || 0;\n\n\t\t\t\tlet tspan = textNode\n\t\t\t\t\t.text( null )\n\t\t\t\t\t.append( 'tspan' )\n\t\t\t\t\t.attr( 'x', x )\n\t\t\t\t\t.attr( 'y', y )\n\t\t\t\t\t.attr( 'dy', `${dy}em` );\n\n\t\t\t\tlet line       = [];\n\t\t\t\tlet lineNumber = 0;\n\t\t\t\twhile ( totalWords.length ) {\n\t\t\t\t\tconst word = totalWords.pop();\n\n\t\t\t\t\t// add this word to the line\n\t\t\t\t\tline.push( word );\n\n\t\t\t\t\t// set the tspan's content to\n\t\t\t\t\t// the value of our line\n\t\t\t\t\ttspan.text( line.join( ' ' ) );\n\n\t\t\t\t\t// determine if the line is now\n\t\t\t\t\t// overflowing\n\t\t\t\t\tconst textLength = tspan\n\t\t\t\t\t\t.node()\n\t\t\t\t\t\t.getComputedTextLength();\n\n\t\t\t\t\tconst overflowing = textLength > width;\n\n\t\t\t\t\tif ( overflowing ) {\n\t\t\t\t\t\t// remove that word, as it was\n\t\t\t\t\t\t// too long\n\t\t\t\t\t\tline.pop();\n\n\t\t\t\t\t\t// reset the text to the line without\n\t\t\t\t\t\t// the word that overflowed\n\t\t\t\t\t\ttspan.text( line.join( ' ' ) );\n\n\t\t\t\t\t\t// put this word in the next line\n\t\t\t\t\t\tline = [word];\n\n\t\t\t\t\t\t// add a new tsapn\n\t\t\t\t\t\ttspan = textNode\n\t\t\t\t\t\t\t.append( 'tspan' )\n\t\t\t\t\t\t\t.attr( 'x', x )\n\t\t\t\t\t\t\t.attr( 'y', y )\n\t\t\t\t\t\t\t.attr( 'dy', `${( ++lineNumber * lineHeight ) + dy}em` )\n\t\t\t\t\t\t\t.text( word );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextNode.selectAll( 'tspan' )\n\t\t\t\t\t.attr( 'dy', ( d, i, tspans ) => {\n\n\t\t\t\t\t\tconst numberOfLines = Array.from( tspans )\n\t\t\t\t\t\t\t.filter( a => a.innerHTML !== '' )\n\t\t\t\t\t\t\t.length - 1;\n\n\t\t\t\t\t\tconst tspanNode  = tspans[i];\n\t\t\t\t\t\tconst startingDy = parseFloat( d3.select( tspanNode ).attr( 'dy' ), 10 );\n\n\t\t\t\t\t\tconst halfTotalTextHeight = ( ( numberOfLines / 2 ) * lineHeight );\n\t\t\t\t\t\tconst linePosition        = ( lineHeight * lineNumber );\n\n\t\t\t\t\t\t// centers the wrapper text\n\t\t\t\t\t\treturn `${( startingDy || 0 ) - linePosition + halfTotalTextHeight}em`;\n\n\t\t\t\t\t} );\n\t\t\t} );\n\t\t},\n\n\t\tpathFromPoints( points, closed = true ) {\n\n\t\t\tconst endCharacter = closed ? ' Z' : '';\n\t\t\tconst path         = points.reduce( ( a, b, i ) => {\n\n\t\t\t\tif ( typeof a !== 'object' ) {\n\t\t\t\t\treturn `${a} L ${b.x} ${b.y}${i === ( points.length - 1 ) ? endCharacter : ''}`;\n\t\t\t\t}\n\n\t\t\t\treturn `M ${b.x} ${b.y}`;\n\n\t\t\t}, {} );\n\n\t\t\treturn path;\n\n\t\t},\n\t},\n};\n</script>\n"]}]}